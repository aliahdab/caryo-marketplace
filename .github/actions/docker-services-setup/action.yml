name: "Docker Services Setup Action"
description: "Sets up Docker services required for testing"

inputs:
  docker-compose-file:
    description: "Path to the docker-compose file to use"
    required: false
    default: './backend/autotrader-backend/docker-compose.dev.yml'
  down-flags:
    description: "Flags to pass to docker-compose down"
    required: false
    default: "--volumes"
  services:
    description: "Space-separated list of services to start"
    required: false
    default: "db minio createbuckets redis"
  wait-time:
    description: "Time in seconds to wait for services to initialize"
    required: false
    default: '60'
  db-container-name:
    description: "Name of the database container"
    required: false
    default: "db"
  db-user:
    description: "Database user"
    required: false
    default: "autotrader"
  minio-health-check:
    description: "Whether to check MinIO health"
    required: false
    default: 'true'
  minio-health-url:
    description: "URL to check MinIO health"
    required: false
    default: "http://localhost:9000/minio/health/ready" # Changed to /ready
  minio-container-name:
    description: "Name of the MinIO container for logging"
    required: false
    default: "minio"
  minio-root-user:
    description: "MinIO root user for authentication"
    required: false
    default: "minioadmin"
  minio-root-password:
    description: "MinIO root password for authentication"
    required: false
    default: "minioadmin"
  createbuckets-container-name: # New input
    description: "Name of the createbuckets container to check"
    required: false
    default: "createbuckets" # Will likely need to be overridden by the caller
  post-minio-ready-wait-seconds:
    description: "Seconds to wait after MinIO is ready before proceeding (e.g., to check createbuckets)"
    required: false
    default: '5'

runs:
  using: "composite"
  steps:
    - name: Set up Docker Compose
      shell: bash
      run: |
        # Ensure Docker and Docker Compose are installed and available
        docker --version
        docker compose version
        
        # Clean up any existing containers
        echo "Cleaning up any existing containers from previous runs..."
        if [ -f "${{ inputs.docker-compose-file }}" ]; then
          docker compose -f ${{ inputs.docker-compose-file }} down ${{ inputs.down-flags }} || true
        fi

    - name: Start required Docker services
      shell: bash
      run: |
        echo "Starting required Docker services: ${{ inputs.services }}"
        # Set MinIO credentials as environment variables for Docker Compose
        export MINIO_ROOT_USER="${{ inputs.minio-root-user }}"
        export MINIO_ROOT_PASSWORD="${{ inputs.minio-root-password }}"
        echo "Using MinIO credentials: User=$MINIO_ROOT_USER"
        
        docker compose -f ${{ inputs.docker-compose-file }} up -d ${{ inputs.services }}
        
        # Give services time to initialize
        echo "Waiting for services to initialize (${{ inputs.wait-time }} seconds)..."
        sleep ${{ inputs.wait-time }}

    - name: Check database health
      shell: bash
      run: |
        echo "Checking PostgreSQL database health..."
        max_retries=10
        retries=0
        
        until docker exec ${{ inputs.db-container-name }} pg_isready -U ${{ inputs.db-user }} || [ $retries -eq $max_retries ]
        do
          echo "Waiting for PostgreSQL to be ready... ($retries/$max_retries)"
          sleep 5
          retries=$((retries+1))
        done
        
        if [ $retries -eq $max_retries ]; then
          echo "PostgreSQL database failed to start in time!"
          docker logs ${{ inputs.db-container-name }}
          exit 1
        else
          echo "PostgreSQL database is ready!"
        fi
        
        # Show running containers
        echo "Running Docker containers:"
        docker ps

    - name: Verify MinIO status
      if: inputs.minio-health-check == 'true'
      shell: bash
      run: |
        echo "Verifying MinIO readiness..."
        max_retries=20 # Further increased retries
        retries=0
        is_ready=false

        # Configure MinIO client with our custom credentials
        echo "Configuring MinIO client with credentials..."
        docker exec ${{ inputs.minio-container-name }} mc config host rm local || echo "No local host config to remove"
        
        # Configure the client with our credentials
        # Adding || true to prevent failing if this doesn't succeed immediately (it will be retried)
        docker exec ${{ inputs.minio-container-name }} mc config host add local http://localhost:9000 ${{ inputs.minio-root-user }} ${{ inputs.minio-root-password }} || echo "Initial mc config failed, will retry"
        
        until [ "$is_ready" == true ] || [ $retries -eq $max_retries ]
        do        
          echo "Attempting MinIO readiness check ($((retries+1))/$max_retries)..."
          
          # Configure client with our credentials again (in case MinIO restarted)
          docker exec ${{ inputs.minio-container-name }} mc config host add local http://localhost:9000 ${{ inputs.minio-root-user }} ${{ inputs.minio-root-password }} || echo "mc config failed, continuing..."
          
          # First, try to list buckets as a simple check
          docker exec ${{ inputs.minio-container-name }} mc ls local/ || echo "mc ls command failed, continuing..."
          
          # Then, check readiness
          if docker exec ${{ inputs.minio-container-name }} mc ready local; then
            echo "MinIO is ready."
            is_ready=true
          else
            echo "MinIO not yet ready. Current MinIO logs (last 20 lines):"
            docker logs ${{ inputs.minio-container-name }} --tail 20
            sleep 8 # Further increased sleep time 
            retries=$((retries+1))
          fi
        done
        
        if [ "$is_ready" != true ]; then
          echo "MinIO failed to become ready after $max_retries attempts."
          echo "Final MinIO logs:"
          docker logs ${{ inputs.minio-container-name }}
          exit 1
        fi
        
        echo "MinIO is confirmed ready. Waiting an additional ${{ inputs.post-minio-ready-wait-seconds }} seconds before proceeding..."
        sleep ${{ inputs.post-minio-ready-wait-seconds }}

    - name: Check createbuckets service completion
      # This step assumes createbuckets is a short-lived container that should run to completion.
      # It runs after MinIO is confirmed to be ready.
      if: inputs.createbuckets-container-name != '' && inputs.createbuckets-container-name != 'none' # Corrected quoting
      shell: bash
      run: |
        echo "Waiting for createbuckets container (${{ inputs.createbuckets-container-name }}) to complete..."
        
        # Wait for the container to stop, with a timeout (e.g., 2 minutes)
        # First, check if container exists
        if ! docker ps -a --format '{{.Names}}' | grep -q "^${{ inputs.createbuckets-container-name }}$"; then
          echo "Warning: createbuckets container ${{ inputs.createbuckets-container-name }} not found. Skipping check."
          exit 0
        fi

        # Wait for container to exit, timeout after 120 seconds
        timeout_seconds=120
        elapsed_seconds=0
        exit_code=""

        while [ $elapsed_seconds -lt $timeout_seconds ]; do
          container_state=$(docker inspect --format='{{.State.Status}}' ${{ inputs.createbuckets-container-name }} 2>/dev/null || echo "notfound")
          if [ "$container_state" == "exited" ]; then
            exit_code=$(docker inspect --format=\'\'{{.State.ExitCode}}\'\' ${{ inputs.createbuckets-container-name }})
            break
          elif [ "$container_state" == "notfound" ]; then
             echo "Error: createbuckets container ${{ inputs.createbuckets-container-name }} disappeared."
             exit 1 # Or handle as a warning
          fi
          sleep 5
          elapsed_seconds=$((elapsed_seconds + 5))
          echo "Waiting for ${{ inputs.createbuckets-container-name }} to exit... ($elapsed_seconds/$timeout_seconds s)"
        done

        if [ -z "$exit_code" ]; then # Container still running or state unknown
            echo "createbuckets container (${{ inputs.createbuckets-container-name }}) did not complete within $timeout_seconds seconds."
            echo "Current state: $(docker inspect --format='{{.State.Status}}' ${{ inputs.createbuckets-container-name }} 2>/dev/null)"
            echo "Attempting to get logs for createbuckets container: ${{ inputs.createbuckets-container-name }}"
            docker logs ${{ inputs.createbuckets-container-name }}
            exit 1
        elif [ "$exit_code" -ne 0 ]; then
            echo "createbuckets container (${{ inputs.createbuckets-container-name }}) completed with error. Exit code: $exit_code"
            echo "Attempting to get logs for createbuckets container: ${{ inputs.createbuckets-container-name }}"
            docker logs ${{ inputs.createbuckets-container-name }}
            exit 1
        else
            echo "createbuckets container (${{ inputs.createbuckets-container-name }}) completed successfully. Exit code: 0"
        fi
