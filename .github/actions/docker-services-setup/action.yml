name: "Docker Services Setup Action"
description: "Sets up Docker services required for testing"

inputs:
  docker-compose-file:
    description: "Path to the docker-compose file to use"
    required: false
    default: './backend/autotrader-backend/docker-compose.dev.yml'
  down-flags:
    description: "Flags to pass to docker-compose down"
    required: false
    default: "--volumes"
  services:
    description: "Space-separated list of services to start"
    required: false
    default: "db minio createbuckets redis"
  wait-time:
    description: "Time in seconds to wait for services to initialize"
    required: false
    default: '60'
  db-container-name:
    description: "Name of the database container"
    required: false
    default: "db"
  db-user:
    description: "Database user"
    required: false
    default: "autotrader"
  minio-health-check:
    description: "Whether to check MinIO health"
    required: false
    default: 'true'
  minio-health-url:
    description: "URL to check MinIO health"
    required: false
    default: "http://localhost:9000/minio/health/ready" # Changed to /ready
  minio-container-name:
    description: "Name of the MinIO container for logging"
    required: false
    default: "minio"
  minio-root-user:
    description: "MinIO root user for authentication"
    required: false
    default: "minioadmin"
  minio-root-password:
    description: "MinIO root password for authentication"
    required: false
    default: "minioadmin"
  createbuckets-container-name: # New input
    description: "Name of the createbuckets container to check"
    required: false
    default: "createbuckets" # Will likely need to be overridden by the caller
  post-minio-ready-wait-seconds:
    description: "Seconds to wait after MinIO is ready before proceeding (e.g., to check createbuckets)"
    required: false
    default: '5'

runs:
  using: "composite"
  steps:
    - name: Set up Docker Compose
      shell: bash
      run: |
        # Ensure Docker and Docker Compose are installed and available
        docker --version
        docker compose version
        
        # Clean up any existing containers
        echo "Cleaning up any existing containers from previous runs..."
        if [ -f "${{ inputs.docker-compose-file }}" ]; then
          docker compose -f ${{ inputs.docker-compose-file }} down ${{ inputs.down-flags }} || true
        fi

    - name: Start required Docker services
      shell: bash
      run: |
        echo "Starting required Docker services: ${{ inputs.services }}"
        # Set MinIO credentials as environment variables for Docker Compose
        export MINIO_ROOT_USER="${{ inputs.minio-root-user }}"
        export MINIO_ROOT_PASSWORD="${{ inputs.minio-root-password }}"
        echo "Using MinIO credentials: User=$MINIO_ROOT_USER"
        
        # Create a .env file to pass environment variables to docker-compose
        echo "MINIO_ROOT_USER=$MINIO_ROOT_USER" > "$(dirname "${{ inputs.docker-compose-file }}")/.env"
        echo "MINIO_ROOT_PASSWORD=$MINIO_ROOT_PASSWORD" >> "$(dirname "${{ inputs.docker-compose-file }}")/.env"
        
        # Show the generated .env file
        echo "Created Docker Compose .env file:"
        cat "$(dirname "${{ inputs.docker-compose-file }}")/.env"
        
        # Start the services with environment variables
        docker compose -f ${{ inputs.docker-compose-file }} up -d ${{ inputs.services }}
        
        # Verify that MinIO container has the environment variables set
        echo "Checking if MinIO container has environment variables set:"
        docker inspect ${{ inputs.minio-container-name }} -f '{{range .Config.Env}}{{println .}}{{end}}' | grep MINIO_ROOT || echo "WARNING: MINIO_ROOT environment variables not found in container"
        
        # Give services time to initialize
        echo "Waiting for services to initialize (${{ inputs.wait-time }} seconds)..."
        sleep ${{ inputs.wait-time }}

    - name: Check database health
      shell: bash
      run: |
        echo "Checking PostgreSQL database health..."
        max_retries=10
        retries=0
        
        until docker exec ${{ inputs.db-container-name }} pg_isready -U ${{ inputs.db-user }} || [ $retries -eq $max_retries ]
        do
          echo "Waiting for PostgreSQL to be ready... ($retries/$max_retries)"
          sleep 5
          retries=$((retries+1))
        done
        
        if [ $retries -eq $max_retries ]; then
          echo "PostgreSQL database failed to start in time!"
          docker logs ${{ inputs.db-container-name }}
          exit 1
        else
          echo "PostgreSQL database is ready!"
        fi
        
        # Show running containers
        echo "Running Docker containers:"
        docker ps

    - name: Verify MinIO status
      if: inputs.minio-health-check == 'true'
      shell: bash
      run: |
        echo "Verifying MinIO readiness..."
        max_retries=20 # Further increased retries
        retries=0
        is_ready=false

        # Pull MinIO logs to check what credentials it's using
        echo "Checking MinIO logs to determine active credentials:"
        docker logs ${{ inputs.minio-container-name }} 2>&1 | grep -i "MINIO_ROOT" || true
        
        # First try to remove any existing hosts
        echo "Configuring MinIO client..."
        docker exec ${{ inputs.minio-container-name }} mc config host rm local &>/dev/null || echo "No local host config to remove"
        docker exec ${{ inputs.minio-container-name }} mc config host rm localhost &>/dev/null || echo "No localhost host config to remove"
        
        # Try both provided and default credentials in case Docker Compose didn't pick up our env vars
        echo "Attempting to configure MinIO client with provided credentials..."
        docker exec ${{ inputs.minio-container-name }} mc config host add local http://localhost:9000 ${{ inputs.minio-root-user }} ${{ inputs.minio-root-password }} &>/dev/null || echo "Config with provided credentials failed, will try defaults"
        
        echo "Attempting to configure MinIO client with default credentials (just in case)..."
        docker exec ${{ inputs.minio-container-name }} mc config host add localhost http://localhost:9000 minioadmin minioadmin &>/dev/null || echo "Config with default credentials failed too"
        
        until [ "$is_ready" == true ] || [ $retries -eq $max_retries ]
        do        
          echo "Attempting MinIO readiness check ($((retries+1))/$max_retries)..."
          
          # Try with provided credentials first
          echo "Trying with provided credentials..."
          if docker exec ${{ inputs.minio-container-name }} mc ready local &>/dev/null; then
            echo "MinIO is ready with provided credentials!"
            is_ready=true
            break
          fi
          
          # Try with default credentials as fallback
          echo "Trying with default credentials..."
          if docker exec ${{ inputs.minio-container-name }} mc ready localhost &>/dev/null; then
            echo "MinIO is ready with default credentials!"
            echo "WARNING: Using default credentials. Custom credentials were not applied."
            is_ready=true
            break
          fi
          
          echo "MinIO not yet ready. Current MinIO logs (last 20 lines):"
          docker logs ${{ inputs.minio-container-name }} --tail 20
          
          # Reconfigure both sets of credentials just to be sure
          docker exec ${{ inputs.minio-container-name }} mc config host rm local &>/dev/null || true
          docker exec ${{ inputs.minio-container-name }} mc config host add local http://localhost:9000 ${{ inputs.minio-root-user }} ${{ inputs.minio-root-password }} &>/dev/null || true
          docker exec ${{ inputs.minio-container-name }} mc config host rm localhost &>/dev/null || true
          docker exec ${{ inputs.minio-container-name }} mc config host add localhost http://localhost:9000 minioadmin minioadmin &>/dev/null || true
          
          sleep 8 # Further increased sleep time 
          retries=$((retries+1))
        done
        
        if [ "$is_ready" != true ]; then
          echo "MinIO failed to become ready after $max_retries attempts."
          echo "Final MinIO logs:"
          docker logs ${{ inputs.minio-container-name }}
          exit 1
        fi
        
        echo "MinIO is confirmed ready. Waiting an additional ${{ inputs.post-minio-ready-wait-seconds }} seconds before proceeding..."
        sleep ${{ inputs.post-minio-ready-wait-seconds }}

    - name: Check createbuckets service completion
      # This step assumes createbuckets is a short-lived container that should run to completion.
      # It runs after MinIO is confirmed to be ready.
      if: inputs.createbuckets-container-name != '' && inputs.createbuckets-container-name != 'none' # Corrected quoting
      shell: bash
      run: |
        echo "Waiting for createbuckets container (${{ inputs.createbuckets-container-name }}) to complete..."
        
        # Wait for the container to stop, with a timeout (e.g., 2 minutes)
        # First, check if container exists
        if ! docker ps -a --format '{{.Names}}' | grep -q "^${{ inputs.createbuckets-container-name }}$"; then
          echo "Warning: createbuckets container ${{ inputs.createbuckets-container-name }} not found. Skipping check."
          exit 0
        fi

        # Wait for container to exit, timeout after 120 seconds
        timeout_seconds=120
        elapsed_seconds=0
        exit_code=""

        while [ $elapsed_seconds -lt $timeout_seconds ]; do
          container_state=$(docker inspect --format='{{.State.Status}}' ${{ inputs.createbuckets-container-name }} 2>/dev/null || echo "notfound")
          if [ "$container_state" == "exited" ]; then
            exit_code=$(docker inspect --format=\'\'{{.State.ExitCode}}\'\' ${{ inputs.createbuckets-container-name }})
            break
          elif [ "$container_state" == "notfound" ]; then
             echo "Error: createbuckets container ${{ inputs.createbuckets-container-name }} disappeared."
             exit 1 # Or handle as a warning
          fi
          sleep 5
          elapsed_seconds=$((elapsed_seconds + 5))
          echo "Waiting for ${{ inputs.createbuckets-container-name }} to exit... ($elapsed_seconds/$timeout_seconds s)"
        done

        if [ -z "$exit_code" ]; then # Container still running or state unknown
            echo "createbuckets container (${{ inputs.createbuckets-container-name }}) did not complete within $timeout_seconds seconds."
            echo "Current state: $(docker inspect --format='{{.State.Status}}' ${{ inputs.createbuckets-container-name }} 2>/dev/null)"
            echo "Attempting to get logs for createbuckets container: ${{ inputs.createbuckets-container-name }}"
            docker logs ${{ inputs.createbuckets-container-name }}
            exit 1
        elif [ "$exit_code" -ne 0 ]; then
            echo "createbuckets container (${{ inputs.createbuckets-container-name }}) completed with error. Exit code: $exit_code"
            echo "Attempting to get logs for createbuckets container: ${{ inputs.createbuckets-container-name }}"
            docker logs ${{ inputs.createbuckets-container-name }}
            exit 1
        else
            echo "createbuckets container (${{ inputs.createbuckets-container-name }}) completed successfully. Exit code: 0"
        fi
