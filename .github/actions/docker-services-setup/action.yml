name: "Docker Services Setup Action"
description: "Sets up Docker services required for testing"

inputs:
  docker-compose-file:
    description: "Path to the docker-compose file to use"
    required: false
    default: './backend/autotrader-backend/docker-compose.dev.yml'
  down-flags:
    description: "Flags to pass to docker-compose down"
    required: false
    default: "--volumes"
  services:
    description: "Space-separated list of services to start"
    required: false
    default: "db minio createbuckets redis"
  wait-time:
    description: "Time in seconds to wait for services to initialize"
    required: false
    default: '60'
  db-container-name:
    description: "Name of the database container"
    required: false
    default: "db"
  db-user:
    description: "Database user"
    required: false
    default: "autotrader"
  minio-health-check:
    description: "Whether to check MinIO health"
    required: false
    default: 'true'
  minio-health-url:
    description: "URL to check MinIO health"
    required: false
    default: "http://localhost:9000/minio/health/ready" # Changed to /ready
  minio-container-name:
    description: "Name of the MinIO container for logging"
    required: false
    default: "minio"
  createbuckets-container-name: # New input
    description: "Name of the createbuckets container to check"
    required: false
    default: "createbuckets" # Will likely need to be overridden by the caller

runs:
  using: "composite"
  steps:
    - name: Set up Docker Compose
      shell: bash
      run: |
        # Ensure Docker and Docker Compose are installed and available
        docker --version
        docker compose version
        
        # Clean up any existing containers
        echo "Cleaning up any existing containers from previous runs..."
        if [ -f "${{ inputs.docker-compose-file }}" ]; then
          docker compose -f ${{ inputs.docker-compose-file }} down ${{ inputs.down-flags }} || true
        fi

    - name: Start required Docker services
      shell: bash
      run: |
        echo "Starting required Docker services: ${{ inputs.services }}"
        docker compose -f ${{ inputs.docker-compose-file }} up -d ${{ inputs.services }}
        
        # Give services time to initialize
        echo "Waiting for services to initialize (${{ inputs.wait-time }} seconds)..."
        sleep ${{ inputs.wait-time }}

    - name: Check database health
      shell: bash
      run: |
        echo "Checking PostgreSQL database health..."
        max_retries=10
        retries=0
        
        until docker exec ${{ inputs.db-container-name }} pg_isready -U ${{ inputs.db-user }} || [ $retries -eq $max_retries ]
        do
          echo "Waiting for PostgreSQL to be ready... ($retries/$max_retries)"
          sleep 5
          retries=$((retries+1))
        done
        
        if [ $retries -eq $max_retries ]; then
          echo "PostgreSQL database failed to start in time!"
          docker logs ${{ inputs.db-container-name }}
          exit 1
        else
          echo "PostgreSQL database is ready!"
        fi
        
        # Show running containers
        echo "Running Docker containers:"
        docker ps

    - name: Verify MinIO status
      if: inputs.minio-health-check == 'true'
      shell: bash
      run: |
        echo "Checking MinIO health status at ${{ inputs.minio-health-url }}..."
        max_retries=12 
        retries=0
        http_status=""
        until [ "$http_status" == "200" ] || [ $retries -eq $max_retries ]
        do
          http_status=$(curl -f -s -o /dev/null -w \'\'%{http_code}\'\' ${{ inputs.minio-health-url }})
          echo "Waiting for MinIO to be ready... ($retries/$max_retries). Status: $http_status"
          sleep 5
          retries=$((retries+1))
        done
        
        if [ "$http_status" != "200" ]; then
          echo "MinIO failed to start in time! Last HTTP status: $http_status"
          echo "Attempting to get logs for MinIO container: ${{ inputs.minio-container-name }}"
          docker logs ${{ inputs.minio-container-name }}
          exit 1
        else
          echo "MinIO is ready! HTTP status: 200"
        fi

    - name: Check createbuckets service completion
      # This step assumes createbuckets is a short-lived container that should run to completion.
      # It runs after MinIO is confirmed to be ready.
      if: inputs.createbuckets-container-name != \'\' && inputs.createbuckets-container-name != \'none\' # Allow skipping if not provided
      shell: bash
      run: |
        echo "Waiting for createbuckets container (${{ inputs.createbuckets-container-name }}) to complete..."
        
        # Wait for the container to stop, with a timeout (e.g., 2 minutes)
        # First, check if container exists
        if ! docker ps -a --format \'\'{{.Names}}\'\' | grep -q "^${{ inputs.createbuckets-container-name }}$"; then
          echo "Warning: createbuckets container ${{ inputs.createbuckets-container-name }} not found. Skipping check."
          exit 0
        fi

        # Wait for container to exit, timeout after 120 seconds
        timeout_seconds=120
        elapsed_seconds=0
        exit_code=""

        while [ $elapsed_seconds -lt $timeout_seconds ]; do
          container_state=$(docker inspect --format=\'\'{{.State.Status}}\'\' ${{ inputs.createbuckets-container-name }} 2>/dev/null || echo "notfound")
          if [ "$container_state" == "exited" ]; then
            exit_code=$(docker inspect --format=\'\'{{.State.ExitCode}}\'\' ${{ inputs.createbuckets-container-name }})
            break
          elif [ "$container_state" == "notfound" ]; then
             echo "Error: createbuckets container ${{ inputs.createbuckets-container-name }} disappeared."
             exit 1 # Or handle as a warning
          fi
          sleep 5
          elapsed_seconds=$((elapsed_seconds + 5))
          echo "Waiting for ${{ inputs.createbuckets-container-name }} to exit... ($elapsed_seconds/$timeout_seconds s)"
        done

        if [ -z "$exit_code" ]; then # Container still running or state unknown
            echo "createbuckets container (${{ inputs.createbuckets-container-name }}) did not complete within $timeout_seconds seconds."
            echo "Current state: $(docker inspect --format=\'\'{{.State.Status}}\'\' ${{ inputs.createbuckets-container-name }} 2>/dev/null)"
            echo "Attempting to get logs for createbuckets container: ${{ inputs.createbuckets-container-name }}"
            docker logs ${{ inputs.createbuckets-container-name }}
            exit 1
        elif [ "$exit_code" -ne 0 ]; then
            echo "createbuckets container (${{ inputs.createbuckets-container-name }}) completed with error. Exit code: $exit_code"
            echo "Attempting to get logs for createbuckets container: ${{ inputs.createbuckets-container-name }}"
            docker logs ${{ inputs.createbuckets-container-name }}
            exit 1
        else
            echo "createbuckets container (${{ inputs.createbuckets-container-name }}) completed successfully. Exit code: 0"
        fi
