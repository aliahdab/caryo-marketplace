name: Reusable Spring Boot Setup

# This is a reusable workflow that handles setting up Gradle, building and running a Spring Boot application
on:
  workflow_call:
    inputs:
      gradle-version:
        description: 'Gradle version to use'
        default: '8.5'
        required: false
        type: string
      spring-profile:
        description: 'Spring Boot profile to use'
        default: 'dev'
        required: false
        type: string
      wait-timeout:
        description: 'How many retries to wait for Spring Boot to become ready'
        default: 45
        required: false
        type: number
      java-version:
        description: 'Java version to use'
        default: '17'
        required: false
        type: string
      working-directory:
        description: 'Directory containing the Spring Boot application'
        default: './backend/autotrader-backend'
        required: false
        type: string
    outputs:
      spring-pid:
        description: "The process ID of the Spring Boot application"
        value: ${{ jobs.setup-spring-boot.outputs.spring-pid }}

jobs:
  setup-spring-boot:
    runs-on: ubuntu-latest
    outputs:
      spring-pid: ${{ steps.start-spring.outputs.pid }}
    
    steps:
    - name: Set up Gradle environment
      run: |
        echo "Setting up Gradle environment with proper permissions..."
        
        # Create a custom Gradle home directory in the workspace
        mkdir -p $GITHUB_WORKSPACE/gradle-home
        echo "GRADLE_USER_HOME=$GITHUB_WORKSPACE/gradle-home" >> $GITHUB_ENV
        
        # Create necessary subdirectories
        mkdir -p $GITHUB_WORKSPACE/gradle-home/wrapper/dists
        mkdir -p $GITHUB_WORKSPACE/gradle-home/caches
        mkdir -p $GITHUB_WORKSPACE/gradle-home/daemon
        
        # Set full permissions on the custom Gradle home
        chmod -R 777 $GITHUB_WORKSPACE/gradle-home
        
        echo "Custom Gradle home directory is ready at $GITHUB_WORKSPACE/gradle-home"

    - name: Set up JDK
      uses: actions/setup-java@v3
      with:
        java-version: ${{ inputs.java-version }}
        distribution: 'temurin'
        
    - name: Verify Gradle Wrapper
      working-directory: ${{ inputs.working-directory }}
      run: |
        echo "Verifying Gradle wrapper files..."
        
        # Check if JAR exists and is valid
        if [ ! -f ./gradle/wrapper/gradle-wrapper.jar ]; then
          echo "ERROR: gradle-wrapper.jar is missing."
          MISSING_JAR=true
        else
          JAR_SIZE=$(stat -c%s ./gradle/wrapper/gradle-wrapper.jar)
          echo "Current gradle-wrapper.jar size: $JAR_SIZE bytes"
          
          # Check for suspiciously small size (LFS pointer is ~130 bytes)
          if [ "$JAR_SIZE" -lt 10000 ]; then
            echo "WARNING: gradle-wrapper.jar is suspiciously small ($JAR_SIZE bytes)."
            echo "Generating a new wrapper..."
            if command -v gradle &> /dev/null; then
              gradle wrapper --gradle-version ${{ inputs.gradle-version }} --distribution-type bin
            else
              echo "Downloading Gradle ${{ inputs.gradle-version }}..."
              GRADLE_ZIP=gradle-${{ inputs.gradle-version }}-bin.zip
              curl -L -o $GRADLE_ZIP https://services.gradle.org/distributions/gradle-${{ inputs.gradle-version }}-bin.zip
              unzip -q -d . $GRADLE_ZIP
              chmod +x ./gradle-${{ inputs.gradle-version }}/bin/gradle
              ./gradle-${{ inputs.gradle-version }}/bin/gradle wrapper --gradle-version ${{ inputs.gradle-version }} --distribution-type bin
              rm -rf gradle-${{ inputs.gradle-version }} $GRADLE_ZIP
            fi
          fi
        fi
        
        # Final verification
        echo "Final verification of gradle-wrapper.jar:"
        ls -la ./gradle/wrapper/gradle-wrapper.jar || echo "gradle-wrapper.jar still missing!"

    - name: Build and start Spring Boot application
      id: start-spring
      working-directory: ${{ inputs.working-directory }}
      run: |
        echo "Building and starting Spring Boot application..."
        # Grant execute permission to gradlew
        chmod +x ./gradlew
        
        # Ensure proper permissions for project Gradle files
        chmod -R u+rwX,go+rX ./gradle
        
        # Create a gradle.properties file to enforce the custom Gradle home
        echo "org.gradle.daemon=false" > gradle.properties
        echo "org.gradle.jvmargs=-Xmx2g -XX:MaxMetaspaceSize=512m -XX:+HeapDumpOnOutOfMemoryError" >> gradle.properties
        
        echo "Using custom Gradle home: $GRADLE_USER_HOME"
        
        # Check for application.properties/yml and ensure database config is correct
        echo "Checking application configuration..."
        if [ -f "src/main/resources/application-${{ inputs.spring-profile }}.yml" ]; then
          echo "Found application-${{ inputs.spring-profile }}.yml:"
          cat src/main/resources/application-${{ inputs.spring-profile }}.yml | grep -A 10 datasource || echo "No datasource configuration found"
        elif [ -f "src/main/resources/application-${{ inputs.spring-profile }}.properties" ]; then
          echo "Found application-${{ inputs.spring-profile }}.properties:"
          cat src/main/resources/application-${{ inputs.spring-profile }}.properties | grep datasource || echo "No datasource configuration found"
        fi
        
        # Build the application
        ./gradlew build -x test --no-daemon || {
          echo "First build attempt failed, trying with more diagnostics..."
          ./gradlew build -x test --no-daemon --stacktrace --info
        }
        
        # Start the application in the background with the specified profile and JVM options
        echo "Starting Spring Boot with enhanced debugging..."
        nohup ./gradlew bootRun --no-daemon \
          -Dorg.gradle.jvmargs="-Xmx1g -XX:+HeapDumpOnOutOfMemoryError -Dfile.encoding=UTF-8" \
          --args='--spring.profiles.active=${{ inputs.spring-profile }} --debug --spring.main.banner-mode=log' \
          > spring-boot.log 2>&1 &
        
        # Store the PID for later cleanup
        SPRING_PID=$!
        echo "pid=$SPRING_PID" >> $GITHUB_OUTPUT
        echo "Spring Boot application started with PID: $SPRING_PID"
        
        # Show initial log output to help with debugging
        sleep 5
        echo "Initial Spring Boot startup log (first 20 lines):"
        head -n 20 spring-boot.log || true
        
        # Wait for Spring Boot to become ready with enhanced diagnostics
        echo "Waiting for Spring Boot application to become ready..."
        MAX_RETRIES=${{ inputs.wait-timeout }}
        RETRY_COUNT=0
        RESTART_COUNT=0
        RESTART_COUNT=0  # Initialize restart counter
        while [ $RETRY_COUNT -lt $MAX_RETRIES ]; do
          echo "Checking Spring Boot health (attempt $((RETRY_COUNT+1))/$MAX_RETRIES)..."
          
          # Check process is still running
          if ! ps -p $SPRING_PID > /dev/null; then
            echo "ERROR: Spring Boot process is not running anymore! Checking logs..."
            cat spring-boot.log
            
            # Track number of restart attempts
            RESTART_COUNT=$((RESTART_COUNT+1))
            if [ ${RESTART_COUNT:-0} -ge 3 ]; then
              echo "ERROR: Spring Boot has crashed ${RESTART_COUNT} times. Not attempting further restarts."
              echo "Last 50 lines of the log:"
              tail -n 50 spring-boot.log
              echo "Checking JVM crash dumps..."
              find . -name "hs_err_*.log" -type f -exec cat {} \; || echo "No JVM crash dumps found."
              echo "Checking system resources..."
              free -m || echo "free command not available"
              df -h || echo "df command not available"
              break
            fi
            
            echo "Attempting restart #${RESTART_COUNT} of the application with extra debug flags..."
            nohup ./gradlew bootRun --no-daemon \
              --args='--spring.profiles.active=${{ inputs.spring-profile }} --debug --logging.level.root=DEBUG --trace' \
              > spring-boot.log 2>&1 &
            SPRING_PID=$!
            echo "pid=$SPRING_PID" >> $GITHUB_OUTPUT
            echo "New process started with PID: $SPRING_PID"
            sleep 20  # Give it more time to stabilize
            continue
          fi
          
          # Try different health endpoints with verbose output
          if curl -s http://localhost:8080/actuator/health | grep -q "UP" || \
             curl -s http://localhost:8080/health | grep -q "UP" || \
             curl -s http://localhost:8080/status | grep -q "UP" || \
             curl -s -I -o /dev/null -w "%{http_code}" http://localhost:8080/ | grep -q "200\|302"; then
            echo "Spring Boot application is ready!"
            break
          fi
          
          # Show current log state periodically
          if [ $((RETRY_COUNT % 5)) -eq 0 ]; then
            echo "Current Spring Boot log tail:"
            tail -n 20 spring-boot.log
            echo "Checking if server is listening on port 8080..."
            netstat -tulpn 2>/dev/null | grep 8080 || echo "No process listening on port 8080"
          fi
          
          RETRY_COUNT=$((RETRY_COUNT+1))
          if [ $RETRY_COUNT -eq $MAX_RETRIES ]; then
            echo "Spring Boot application failed to become ready in time."
            echo "Full application log:"
            cat spring-boot.log
          fi
          sleep 10
        done

    - name: Verify API is Accessible
      working-directory: ${{ inputs.working-directory }}
      run: |
        echo "Performing final API verification..."
        curl -v http://localhost:8080/ || echo "Failed to connect to root endpoint"
        
        echo "Listening ports:"
        netstat -tulpn 2>/dev/null | grep 8080 || ss -tulwn 2>/dev/null | grep 8080 || echo "No process listening on port 8080"
