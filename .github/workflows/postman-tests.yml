name: Postman API Tests

on:
  workflow_dispatch:
  pull_request:
    branches: [main, develop]
  push:
    branches: [main, develop]
  schedule:
    - cron: '0 0 * * 1'

jobs:
  api-tests:
    runs-on: ubuntu-latest
    timeout-minutes: 30
    if: |
      github.event_name == 'workflow_dispatch' ||
      github.event_name == 'schedule' ||
      (github.event_name == 'push' && (github.ref == 'refs/heads/main' || github.ref == 'refs/heads/develop')) ||
      github.event_name == 'pull_request'

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          lfs: true
        
      - name: Setup Gradle Environment
        uses: ./.github/actions/gradle-setup
        with:
          working-directory: "./backend/autotrader-backend"
          java-version: "17"
          gradle-version: "8.5"
          cache: true
        
      - name: Ensure Gradle Wrapper
        working-directory: ./backend/autotrader-backend
        run: |
          if [ ! -f "./gradlew" ]; then
            echo "gradlew script not found! Generating a new one..."
            if command -v gradle &> /dev/null; then
              gradle wrapper --gradle-version=8.5
            else
              echo "ERROR: Could not generate wrapper with Gradle CLI"
              exit 1
            fi
          fi
          chmod +x ./gradlew

      - name: Setup Docker Services
        uses: ./.github/actions/docker-services-setup
        with:
          docker-compose-file: "./backend/autotrader-backend/docker-compose.dev.yml"
          services: "db minio createbuckets redis"
          wait-time: '60'
          db-container-name: "autotrader-backend-db-1"
          db-user: "autotrader"
          minio-container-name: "autotrader-backend-minio-1"
          createbuckets-container-name: "autotrader-backend-createbuckets-1"
          post-minio-ready-wait-seconds: '10'
          # Using the default MinIO credentials that are in docker-compose.dev.yml
          minio-root-user: "minioadmin"
          minio-root-password: "minioadmin"

      # Add explicit MinIO bucket verification and creation step
      - name: Ensure MinIO bucket exists
        run: |
          echo "Verifying MinIO bucket existence..."
          
          # Install MinIO client
          curl -O https://dl.min.io/client/mc/release/linux-amd64/mc
          chmod +x mc
          
          # Configure MinIO client with default minioadmin credentials
          ./mc config host add myminio http://localhost:9000 minioadmin minioadmin
          
          # List buckets to check if our bucket exists
          if ./mc ls myminio | grep -q "autotrader-assets"; then
            echo "‚úÖ autotrader-assets bucket exists!"
          else
            echo "‚ö†Ô∏è autotrader-assets bucket not found, creating it..."
            ./mc mb --ignore-existing myminio/autotrader-assets
            ./mc policy set download myminio/autotrader-assets
            echo "‚úÖ Created autotrader-assets bucket with download policy"
          fi
          
          # Double-check creation
          ./mc ls myminio

      - name: Create application-dev.yml
        working-directory: ./backend/autotrader-backend
        run: |
          mkdir -p src/main/resources
          cat << 'EOC' > src/main/resources/application-dev.yml
          spring:
            datasource:
              url: jdbc:postgresql://localhost:5432/autotrader
              username: autotrader
              password: autotrader
            servlet:
              multipart:
                max-file-size: 10MB
                max-request-size: 10MB
            jpa:
              hibernate:
                ddl-auto: update
              properties:
                hibernate:
                  dialect: org.hibernate.dialect.PostgreSQLDialect
                  format_sql: false
                  show_sql: false
            mail:
              host: localhost
              port: 1025
              username: admin
              password: password
          minio:
            endpoint: http://localhost:9000
            accessKey: minioadmin
            secretKey: minioadmin
            bucket: autotrader-assets
          logging:
            level:
              root: INFO
              com.autotrader: INFO
              org.springframework.web: INFO
              org.hibernate: WARN
          server:
            port: 8080
          EOC

      - name: Prepare Configuration
        working-directory: ./backend/autotrader-backend
        run: |
          # Create application-test.yml with necessary configs
          echo "Creating application-test.yml file..."
          mkdir -p src/main/resources
          
          cat > src/main/resources/application-test.yml << EOF
          # Test configuration that inherits from dev profile
          spring:
            config:
              import: application-dev.yml
            # Enable data initialization
            jpa:
              defer-datasource-initialization: true
            sql:
              init:
                mode: always
          
          # Enable debug logging for DataInitializer
          logging:
            level:
              com.autotrader.autotraderbackend.config.DataInitializer: DEBUG
          EOF
      
      - name: Start Spring Boot Application
        id: spring-boot-start
        uses: ./.github/actions/spring-boot-setup
        with:
          working-directory: "./backend/autotrader-backend"
          spring-profiles: "test"
          debug-mode: "false"
          wait-retries: "30"
          wait-time: "10"
          skip-build: "false"
          server-port: "8080"
          
      - name: Wait for data initialization and extract tokens
        working-directory: ./backend/autotrader-backend
        run: |
          # Wait to ensure DataInitializer finishes and logs tokens
          echo "Waiting for DataInitializer to complete..."
          
          # Instead of a fixed sleep, poll the logs for a sign that initialization is complete
          LOG_FILE="spring-boot.log"
          MAX_ATTEMPTS=12
          ATTEMPT=1
          INIT_COMPLETE=false
          
          while [ $ATTEMPT -le $MAX_ATTEMPTS ] && [ "$INIT_COMPLETE" = "false" ]; do
            echo "Checking for initialization completion (attempt $ATTEMPT/$MAX_ATTEMPTS)..."
            
            # Check if log contains indication that data initialization is complete
            if grep -q "DataInitializer completed" $LOG_FILE 2>/dev/null || \
               grep -q "DEVELOPMENT AUTHENTICATION TOKENS" $LOG_FILE 2>/dev/null; then
              echo "‚úÖ Data initialization appears to be complete!"
              INIT_COMPLETE=true
            else
              echo "Still waiting for initialization to complete..."
              sleep 5
              ATTEMPT=$((ATTEMPT+1))
            fi
          done
          
          # Application health check
          echo "Performing application health check..."
          HEALTH_STATUS=$(curl -s -o /dev/null -w "%{http_code}" http://localhost:8080/actuator/health)
          if [ "$HEALTH_STATUS" -eq 200 ]; then
            echo "‚úÖ Application health check successful (status $HEALTH_STATUS)"
          else
            echo "‚ö†Ô∏è Application health check returned status $HEALTH_STATUS"
            echo "Retrieving health details..."
            curl -s http://localhost:8080/actuator/health | jq '.' || echo "Could not retrieve health details"
          fi
          
          # Verify the application is running with correct profiles
          echo "Verifying active profiles..."
          PROFILES_OUTPUT=$(curl -s http://localhost:8080/actuator/env/spring.profiles.active || echo "")
          if [ ! -z "$PROFILES_OUTPUT" ]; then
            echo "Active profiles: $PROFILES_OUTPUT"
            if echo "$PROFILES_OUTPUT" | grep -q "test"; then
              echo "‚úÖ Application started with test profile!"
              # Check if dev profile is also active (imported by test)
              if echo "$PROFILES_OUTPUT" | grep -q "dev"; then
                echo "‚úÖ Dev profile is also active (imported by test profile)"
              fi
            else
              echo "‚ö†Ô∏è Profile verification failed! Continuing anyway..."
            fi
          else
            echo "Could not retrieve active profiles. Continuing anyway..."
          fi
          
          # Check for generated tokens in logs
          echo "Looking for authentication tokens in logs..."
          if grep -q "DEVELOPMENT AUTHENTICATION TOKENS" $LOG_FILE; then
            echo "Found authentication tokens section in logs:"
            awk '/====== DEVELOPMENT AUTHENTICATION TOKENS ======/{flag=1; print; next} /==============================================/{flag=0} flag' $LOG_FILE || true
            
            # Extract admin token explicitly with better error handling
            ADMIN_TOKEN=$(grep -A 10 "ADMIN USER TOKEN" $LOG_FILE | grep -v "ADMIN USER TOKEN" | grep -v "----" | grep -v "^$" | head -1 | tr -d ' ' || echo "")
            if [ ! -z "$ADMIN_TOKEN" ]; then
              echo "‚úÖ Successfully extracted admin token!"
              # Validate token format before setting
              if [[ $ADMIN_TOKEN == eyJ* ]]; then
                echo "ADMIN_TOKEN=$ADMIN_TOKEN" >> $GITHUB_ENV
                echo "Admin token has expected JWT format"
              else
                echo "‚ö†Ô∏è Admin token doesn't match expected JWT format, might be invalid"
                echo "ADMIN_TOKEN=$ADMIN_TOKEN" >> $GITHUB_ENV
              fi
            fi
            
            # Extract regular user token explicitly with better error handling
            USER_TOKEN=$(grep -A 10 "REGULAR USER TOKEN" $LOG_FILE | grep -v "REGULAR USER TOKEN" | grep -v "----" | grep -v "^$" | head -1 | tr -d ' ' || echo "")
            if [ ! -z "$USER_TOKEN" ]; then
              echo "‚úÖ Successfully extracted regular user token!"
              # Validate token format before setting
              if [[ $USER_TOKEN == eyJ* ]]; then
                echo "USER_TOKEN=$USER_TOKEN" >> $GITHUB_ENV
                echo "User token has expected JWT format"
              else
                echo "‚ö†Ô∏è User token doesn't match expected JWT format, might be invalid"
                echo "USER_TOKEN=$USER_TOKEN" >> $GITHUB_ENV
              fi
            fi
          else
            echo "No tokens found in logs, dumping recent log entries..."
            tail -n 100 $LOG_FILE
            echo "Will attempt direct authentication in next step"
          fi
          
          # Summarize token extraction results
          if [ ! -z "$ADMIN_TOKEN" ]; then
            echo "‚úÖ Admin token available for tests"
          else
            echo "‚ö†Ô∏è No admin token extracted"
          fi
          
          if [ ! -z "$USER_TOKEN" ]; then
            echo "‚úÖ User token available for tests"
          else
            echo "‚ö†Ô∏è No user token extracted"
          fi

      - name: Install Newman
        run: npm install -g newman newman-reporter-htmlextra

      - name: Prepare Authentication Token
        id: prepare-auth
        working-directory: ./backend/autotrader-backend
        run: |
          # Verify the API is running correctly
          echo "Checking API endpoints..."
          curl -i http://localhost:8080/actuator/health
          
          # Verify the DataInitializer created the default users
          echo "Verifying DataInitializer users were created..."
          docker exec -i $(docker ps -qf "name=autotrader-backend-db-1") psql -U autotrader -d autotrader -c "SELECT id, username, email FROM users WHERE username IN ('admin', 'user')"
          
          # Use the previously extracted tokens if available
          if [ ! -z "$ADMIN_TOKEN" ]; then
            echo "‚úÖ Using previously extracted admin token"
            TOKEN="$ADMIN_TOKEN"
          elif [ ! -z "$USER_TOKEN" ]; then
            echo "‚úÖ Using previously extracted user token"
            TOKEN="$USER_TOKEN"
          else
            # Try to authenticate directly with the default admin user
            echo "No tokens found in environment, trying direct authentication..."
            AUTH_RESPONSE=$(curl -s -X POST http://localhost:8080/auth/signin \
              -H "Content-Type: application/json" \
              -d '{"username":"admin","password":"Admin123!"}' 2>&1)
            echo "Auth response received."
            
            # Try to extract token from direct authentication
            TOKEN=$(echo "$AUTH_RESPONSE" | jq -r '.token // .accessToken // .access_token // ""')
            
            # If direct auth failed, create a test user
            if [ -z "$TOKEN" ] || [ "$TOKEN" == "null" ]; then
                echo "‚ö†Ô∏è Direct auth failed. Creating test user via signup..."
                curl -s -X POST http://localhost:8080/auth/signup \
                  -H "Content-Type: application/json" \
                  -d '{"username":"testapi","email":"testapi@example.com","password":"password123"}'
                
                sleep 2
                
                echo "Authenticating with test user..."
                AUTH_RESPONSE=$(curl -s -X POST http://localhost:8080/auth/signin \
                  -H "Content-Type: application/json" \
                  -d '{"username":"testapi","password":"password123"}')
                
                TOKEN=$(echo "$AUTH_RESPONSE" | jq -r '.token // .accessToken // .access_token // ""')
            fi
            
            # Last resort - use a fallback token if all methods fail
            if [ -z "$TOKEN" ] || [ "$TOKEN" == "null" ]; then
                echo "‚ö†Ô∏è All authentication attempts failed. Using fallback token."
                TOKEN="eyJhbGciOiJIUzI1NiJ9.eyJzdWIiOiJhZG1pbiIsImlhdCI6MTYyNjk1NDU4OCwiZXhwIjoxNjI3MDQwOTg4fQ.test-token-placeholder"
            fi
          fi
          
          echo "Using token: ${TOKEN:0:25}..."
          echo "AUTH_TOKEN=$TOKEN" >> $GITHUB_ENV
          
          # Find the collection file
          echo "Locating Postman collection file..."
          COLLECTION_FILES=$(find ./src/test/resources -name "autotrader-api-collection.json" 2>/dev/null || find ./src/test/resources -name "*.json" -not -path "*/node_modules/*" | head -1)
          
          if [ -z "$COLLECTION_FILES" ]; then
            echo "No JSON files found in test resources!"
            exit 1
          fi
          
          COLLECTION=$(echo "$COLLECTION_FILES" | head -1)
          echo "Using collection: $COLLECTION"
          # Store absolute path for later use
          COLLECTION_ABS_PATH=$(readlink -f "$COLLECTION")
          echo "COLLECTION_PATH=$COLLECTION_ABS_PATH" >> $GITHUB_OUTPUT
          
          # Verify API access with token
          echo "Verifying API access with token..."
          HTTP_STATUS=$(curl -s -o /dev/null -w "%{http_code}" -H "Authorization: Bearer $TOKEN" http://localhost:8080/api/reference-data)
          echo "Reference data endpoint status: $HTTP_STATUS"
          
          if [ "$HTTP_STATUS" -ge 200 ] && [ "$HTTP_STATUS" -lt 300 ]; then
              echo "‚úÖ Authentication is working correctly!"
          else
              echo "‚ö†Ô∏è Authentication issue detected. Trying health endpoint..."
              curl -i -H "Authorization: Bearer $TOKEN" http://localhost:8080/actuator/health
          fi
          
          # Create results directory
          mkdir -p ../../results

      - name: Run Postman Tests with Newman
        id: postman-tests
        uses: ./.github/actions/postman-tests
        with:
          collection-path: "${{ steps.prepare-auth.outputs.COLLECTION_PATH }}"
          environment-file: './postman/test_environment.json'
          working-directory: './backend/autotrader-backend'
          results-directory: './results'
          auto-detect-collection: 'true'
          extra-options: '--bail --export-environment ./results/updated_environment.json'
        
      - name: Upload test results and logs
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: test-artifacts
          path: |
            results/**
            ./backend/autotrader-backend/spring-boot*.log
            ./backend/autotrader-backend/build/reports/**/*
            ./postman/test_environment.json
            ./results/updated_environment.json
          retention-days: 7

      - name: Publish Test Summary
        if: always()
        run: |
          echo "## API Test Results Summary" >> $GITHUB_STEP_SUMMARY
          
          echo "### Spring Boot Application" >> $GITHUB_STEP_SUMMARY
          echo "- Profile: test (with dev profile imported)" >> $GITHUB_STEP_SUMMARY
          echo "- PID: ${{ steps.spring-boot-start.outputs.pid }}" >> $GITHUB_STEP_SUMMARY
          
          echo "### Test Execution" >> $GITHUB_STEP_SUMMARY
          if [ "${{ steps.postman-tests.outcome }}" == "success" ]; then
            echo "- Status: ‚úÖ All tests passed" >> $GITHUB_STEP_SUMMARY
          else
            echo "- Status: ‚ùå Some tests failed" >> $GITHUB_STEP_SUMMARY
          fi
          
          echo "### Authentication" >> $GITHUB_STEP_SUMMARY
          if [ ! -z "$ADMIN_TOKEN" ]; then
            echo "- Admin token: ‚úÖ Available" >> $GITHUB_STEP_SUMMARY
          else
            echo "- Admin token: ‚ùå Not available" >> $GITHUB_STEP_SUMMARY
          fi
          
          if [ ! -z "$USER_TOKEN" ]; then
            echo "- User token: ‚úÖ Available" >> $GITHUB_STEP_SUMMARY
          else
            echo "- User token: ‚ùå Not available" >> $GITHUB_STEP_SUMMARY
          fi
          
          echo "### Artifacts" >> $GITHUB_STEP_SUMMARY
          echo "- Test Results: results/" >> $GITHUB_STEP_SUMMARY
          echo "- Application Logs: backend/autotrader-backend/spring-boot.log" >> $GITHUB_STEP_SUMMARY
          
          echo "For more details, download the test artifacts."

      - name: Cleanup test environment
        if: always()
        run: |
          # Get the Spring Boot PID from the composite action output
          SPRING_PID="${{ steps.spring-boot-start.outputs.pid }}"
          echo "Spring Boot PID from setup: $SPRING_PID"
          
          # Kill Spring Boot process with a safer approach
          if [ ! -z "$SPRING_PID" ]; then
            echo "Gracefully stopping Spring Boot process with PID: $SPRING_PID"
            kill -15 $SPRING_PID 2>/dev/null || true
            
            # Give it a chance to gracefully exit
            echo "Waiting for process to exit gracefully..."
            for i in {1..5}; do
              if ! ps -p $SPRING_PID > /dev/null 2>&1; then
                echo "‚úÖ Spring Boot process stopped successfully"
                break
              fi
              sleep 1
            done
            
            # Force kill if still running
            if ps -p $SPRING_PID > /dev/null 2>&1; then
              echo "Process still running, force killing..."
              kill -9 $SPRING_PID 2>/dev/null || true
              sleep 1
            fi
          fi
          
          # Check for any remaining Java processes (safety net)
          echo "Checking for any remaining Java processes..."
          JAVA_PIDS=$(ps aux | grep java | grep -v grep | awk '{print $2}')
          if [ ! -z "$JAVA_PIDS" ]; then
            echo "Found Java processes: $JAVA_PIDS"
            for pid in $JAVA_PIDS; do
              echo "Force killing Java process $pid"
              kill -9 $pid 2>/dev/null || true
            done
          else
            echo "‚úÖ No leftover Java processes found"
          fi
          
          # Stop Docker services and clean volumes
          echo "Stopping Docker services..."
          cd ./backend/autotrader-backend
          docker compose -f docker-compose.dev.yml down -v
          echo "‚úÖ Docker services and volumes cleaned up"
          
      - name: Notify on test failures
        if: failure() && (github.event_name == 'push' || github.event_name == 'schedule')
        uses: actions/github-script@v6
        with:
          script: |
            const { owner, repo } = context.repo;
            
            // Create a summary of the failure
            const workflowName = 'Postman API Tests';
            const runUrl = `https://github.com/${owner}/${repo}/actions/runs/${context.runId}`;
            const jobName = 'api-tests';
            
            // Get branch/tag name
            const ref = context.ref.replace('refs/heads/', '').replace('refs/tags/', '');
            
            const body = `## ‚ùå ${workflowName} Failed
            
            * **Branch/Tag**: ${ref}
            * **Workflow Run**: [View details](${runUrl})
            * **Job**: ${jobName}
            
            Please check the logs for more details on the failure.
            `;
            
            // Create an issue for the failure if this is a scheduled run or push to main branches
            if (context.eventName === 'schedule' || 
               (context.eventName === 'push' && 
               (context.ref === 'refs/heads/main' || context.ref === 'refs/heads/develop'))) {
              
              await github.rest.issues.create({
                owner,
                repo,
                title: `üî¥ ${workflowName} failed on ${ref}`,
                body: body,
                labels: ['bug', 'automation', 'test-failure']
              });
              
              console.log('Created issue for test failure');
            } else {
              console.log('Skipping issue creation for non-critical branch or event');
            }
