name: Postman API Tests

on:
  workflow_dispatch:  
  pull_request:
    branches:
      - main 
  schedule:
    - cron: '0 0 * * 1'  # Run weekly on Mondays at midnight

jobs:
  api-tests:
    runs-on: ubuntu-latest
    timeout-minutes: 20  # Prevent hanging builds
    
    steps:
    - uses: actions/checkout@v4
      with:
        fetch-depth: 0
        lfs: true # Explicitly enable LFS file download

    # Verify and fix Gradle wrapper if needed (for backend builds)
    - name: Set up Gradle environment
      run: |
        echo "Setting up Gradle environment with proper permissions..."
        
        # Create a custom Gradle home directory in the workspace instead of /home/runner/.gradle
        mkdir -p $GITHUB_WORKSPACE/gradle-home
        echo "GRADLE_USER_HOME=$GITHUB_WORKSPACE/gradle-home" >> $GITHUB_ENV
        
        # Create necessary subdirectories
        mkdir -p $GITHUB_WORKSPACE/gradle-home/wrapper/dists
        mkdir -p $GITHUB_WORKSPACE/gradle-home/caches
        mkdir -p $GITHUB_WORKSPACE/gradle-home/daemon
        
        # Set full permissions on the custom Gradle home
        chmod -R 777 $GITHUB_WORKSPACE/gradle-home
        
        # List directory contents to verify setup
        echo "Checking custom Gradle home setup:"
        ls -la $GITHUB_WORKSPACE/gradle-home/
        
        echo "Custom Gradle home directory is ready at $GITHUB_WORKSPACE/gradle-home"

    - name: Verify Gradle Wrapper (if backend build is needed)
      working-directory: ./backend/autotrader-backend
      run: |
        echo "Verifying Gradle wrapper files..."
        
        # Check if JAR exists and is valid
        if [ ! -f ./gradle/wrapper/gradle-wrapper.jar ]; then
          echo "ERROR: gradle-wrapper.jar is missing."
          MISSING_JAR=true
        else
          JAR_SIZE=$(stat -c%s ./gradle/wrapper/gradle-wrapper.jar)
          echo "Current gradle-wrapper.jar size: $JAR_SIZE bytes"
          
          # Check for suspiciously small size (LFS pointer is ~130 bytes)
          if [ "$JAR_SIZE" -lt 10000 ]; then
            echo "WARNING: gradle-wrapper.jar is suspiciously small ($JAR_SIZE bytes). It might be an LFS pointer."
            echo "Content of the suspicious file:"
            cat ./gradle/wrapper/gradle-wrapper.jar
            
            # Fix the wrapper
            echo "Generating a new wrapper..."
            if command -v gradle &> /dev/null; then
              gradle wrapper --gradle-version 8.5 --distribution-type bin
            else
              echo "Downloading Gradle 8.5..."
              GRADLE_ZIP=gradle-8.5-bin.zip
              curl -L -o $GRADLE_ZIP https://services.gradle.org/distributions/gradle-8.5-bin.zip
              unzip -q -d . $GRADLE_ZIP
              chmod +x ./gradle-8.5/bin/gradle
              ./gradle-8.5/bin/gradle wrapper --gradle-version 8.5 --distribution-type bin
              rm -rf gradle-8.5 $GRADLE_ZIP
            fi
            
            # Verify new wrapper
            if [ -f ./gradle/wrapper/gradle-wrapper.jar ]; then
              NEW_SIZE=$(stat -c%s ./gradle/wrapper/gradle-wrapper.jar)
              echo "New gradle-wrapper.jar generated. Size: $NEW_SIZE bytes"
            fi
          fi
        fi
        
        # Final verification
        echo "Final verification of gradle-wrapper.jar:"
        ls -la ./gradle/wrapper/gradle-wrapper.jar || echo "gradle-wrapper.jar still missing!"
        file ./gradle/wrapper/gradle-wrapper.jar || echo "Cannot get file info"

    # Set up environment for API tests
    - name: Set up environment
      run: |
        echo "Setting up test environment"
        
        # Start Docker services if needed
        if [ -f "./backend/autotrader-backend/docker-compose.dev.yml" ]; then
          echo "Starting backend services with Docker Compose..."
          cd ./backend/autotrader-backend
          docker compose -f docker-compose.dev.yml up -d
          cd -
          
          # Wait for services to be available
          echo "Waiting for services to initialize (60 seconds)..."
          sleep 60
          
          # Check service health
          echo "Checking service health..."
          if docker ps | grep -q "db"; then
            echo "Checking PostgreSQL readiness..."
            MAX_RETRIES=15
            RETRY_COUNT=0
            while [ $RETRY_COUNT -lt $MAX_RETRIES ]; do
              if docker exec $(docker ps -q -f name=db) pg_isready -U autotrader -t 15 2>/dev/null; then
                echo "PostgreSQL is ready!"
                break
              else
                RETRY_COUNT=$((RETRY_COUNT+1))
                echo "PostgreSQL not ready yet. Attempt $RETRY_COUNT of $MAX_RETRIES"
                if [ $RETRY_COUNT -eq $MAX_RETRIES ]; then
                  echo "PostgreSQL failed to become ready. Showing logs but continuing..."
                  docker logs $(docker ps -q -f name=db)
                fi
                sleep $((RETRY_COUNT * 5))
              fi
            done
          fi
        else
          echo "No Docker Compose file found. Assuming services are already running remotely."
        fi

    # Build and start the Spring Boot backend application
    - name: Set up JDK 17
      uses: actions/setup-java@v3
      with:
        java-version: '17'
        distribution: 'temurin'
        
    - name: Build and start Spring Boot application
      working-directory: ./backend/autotrader-backend
      run: |
        echo "Building and starting Spring Boot application..."
        # Grant execute permission to gradlew
        chmod +x ./gradlew
        
        # Ensure proper permissions for project Gradle files
        echo "Setting permissions for project Gradle files..."
        chmod -R u+rwX,go+rX ./gradle
        
        # Create a gradle.properties file to enforce the custom Gradle home
        echo "org.gradle.daemon=false" > gradle.properties
        echo "org.gradle.jvmargs=-Xmx2g -XX:MaxMetaspaceSize=512m -XX:+HeapDumpOnOutOfMemoryError" >> gradle.properties
        
        echo "Using custom Gradle home: $GRADLE_USER_HOME"
        
        # Try with no daemon mode first
        ./gradlew build -x test --no-daemon || {
          echo "First build attempt failed, trying with more diagnostics..."
          
          # Check if Gradle home is accessible and writable
          echo "Verifying Gradle home directory:"
          ls -la $GRADLE_USER_HOME
          touch $GRADLE_USER_HOME/test_write && echo "Write test passed" || echo "Write test failed"
          
          # Try with specific properties for troubleshooting
          echo "Retrying with debug flags..."
          ./gradlew build -x test --no-daemon --stacktrace --info
        }
        
        # Start the application in the background with dev profile
        nohup ./gradlew bootRun --no-daemon --args='--spring.profiles.active=dev' > spring-boot.log 2>&1 &
        
        # Store the PID for later cleanup
        echo "SPRING_PID=$!" >> $GITHUB_ENV
        
        echo "Spring Boot application started with PID: $!"
        
        # Wait for Spring Boot to become ready
        echo "Waiting for Spring Boot application to become ready..."
        MAX_RETRIES=30
        RETRY_COUNT=0
        while [ $RETRY_COUNT -lt $MAX_RETRIES ]; do
          echo "Checking Spring Boot health (attempt $((RETRY_COUNT+1))/$MAX_RETRIES)..."
          
          # Try different health endpoints
          if curl -s http://localhost:8080/actuator/health 2>/dev/null | grep -q "UP"; then
            echo "Spring Boot application is ready! (via actuator)"
            break
          elif curl -s http://localhost:8080/health 2>/dev/null | grep -q "UP"; then
            echo "Spring Boot application is ready! (via health)"
            break
          elif curl -s http://localhost:8080/status 2>/dev/null | grep -q "UP"; then
            echo "Spring Boot application is ready! (via status)"
            break
          elif curl -s -I -o /dev/null -w "%{http_code}" http://localhost:8080/ 2>/dev/null | grep -q "200\|302"; then
            echo "Spring Boot application is ready! (via root path)"
            break
          else
            RETRY_COUNT=$((RETRY_COUNT+1))
            if [ $RETRY_COUNT -eq $MAX_RETRIES ]; then
              echo "Spring Boot application failed to become ready in time. Showing logs..."
              cat spring-boot.log
              # Don't exit here, try to run the tests anyway
            fi
            sleep 10
          fi
        done

    - name: Install Newman
      run: npm install -g newman newman-reporter-htmlextra

    - name: Create Results Directory
      run: mkdir -p results

    - name: Run Postman Collection
      run: |
        echo "Running Postman collection tests..."
        # Determine which collection file to use
        if [ -f "./postman/Caryo_Marketplace_API_Tests.json" ]; then
          COLLECTION_PATH="./postman/Caryo_Marketplace_API_Tests.json"
          echo "Using Caryo_Marketplace_API_Tests.json collection file"
        elif [ -f "./backend/autotrader-backend/src/test/resources/postman/autotrader-api-collection.json" ]; then
          COLLECTION_PATH="./backend/autotrader-backend/src/test/resources/postman/autotrader-api-collection.json"
          echo "Using autotrader-api-collection.json collection file"
        else
          echo "ERROR: Postman collection file not found"
          echo "Searching for collection files in project..."
          find . -name "*.json" | grep -i -E "collection|postman|api[-_]test"
          exit 1
        fi
        
        newman run "$COLLECTION_PATH" \
          --environment ./postman/test_environment.json \
          --reporters cli,junit,htmlextra \
          --reporter-junit-export results/junit-report.xml \
          --reporter-htmlextra-export results/html-report.html

    - name: Upload test results
      if: always()
      uses: actions/upload-artifact@v4
      with:
        name: postman-test-results
        path: results/

    # Cleanup test environment if needed
    - name: Cleanup
      if: always()
      run: |
        echo "Cleaning up test environment"
        
        # Stop Spring Boot application if it was started
        if [ ! -z "$SPRING_PID" ]; then
          echo "Stopping Spring Boot application (PID: $SPRING_PID)..."
          kill $SPRING_PID || true
          echo "Spring Boot logs (last 50 lines):"
          if [ -f "./backend/autotrader-backend/spring-boot.log" ]; then
            tail -n 50 ./backend/autotrader-backend/spring-boot.log
          fi
        fi
        
        # Stop Docker services if they were started
        if [ -f "./backend/autotrader-backend/docker-compose.dev.yml" ]; then
          echo "Stopping Docker services..."
          cd ./backend/autotrader-backend
          docker compose -f docker-compose.dev.yml down -v
          cd -
        fi
        echo "Cleanup complete"
