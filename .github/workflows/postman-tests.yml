name: Postman API Tests (Standalone)

on:
  workflow_dispatch:
  pull_request:
    branches:
      - develop
      - main
  schedule:
    - cron: '0 0 * * 1'  # Run weekly on Mondays at midnight

jobs:
  api-tests:
    runs-on: ubuntu-latest
    timeout-minutes: 30  # Increased timeout to prevent hanging builds

    steps:
    - uses: actions/checkout@v4
      with:
        fetch-depth: 0
        lfs: true # Explicitly enable LFS file download
        
    # Setup Gradle Environment
    - name: Setup Gradle Environment
      uses: ./.github/actions/gradle-setup
      with:
        working-directory: "./backend/autotrader-backend"
        java-version: "17"
        gradle-version: "8.5"
        cache: true
        
    # Ensure Gradle Wrapper exists as in original file
    # Ensure Gradle Wrapper exists
    - name: Ensure Gradle Wrapper
      working-directory: ./backend/autotrader-backend
      run: |
        echo "Checking for Gradle wrapper files..."
        if [ ! -f "./gradlew" ]; then
          echo "gradlew script not found! Generating a new one..."
          
          # First try to use the Gradle CLI if available
          if command -v gradle &> /dev/null; then
            echo "Using gradle CLI to generate wrapper"
            gradle wrapper --gradle-version=8.5
          elif [ -f "../gradle/wrapper/gradle-wrapper.jar" ]; then
            echo "Copying Gradle wrapper from parent directory"
            mkdir -p ./gradle/wrapper/
            cp ../gradle/wrapper/gradle-wrapper.jar ./gradle/wrapper/
            cp ../gradle/wrapper/gradle-wrapper.properties ./gradle/wrapper/
            cp ../gradlew ./
            cp ../gradlew.bat ./
            chmod +x ./gradlew
          else
            echo "ERROR: Could not generate or find Gradle wrapper!"
            echo "Current directory structure:"
            ls -la ./
            echo "Parent directory structure:"
            ls -la ../
            exit 1
          fi
        fi
        
        echo "Verifying gradlew exists and is executable:"
        if [ -f "./gradlew" ]; then
          ls -la ./gradlew
          echo "Ensuring gradlew is executable"
          chmod +x ./gradlew
        else
          echo "ERROR: gradlew still not found after attempt to generate/copy!"
          exit 1
        fi

    # Setup Docker Services
    - name: Setup Docker Services
      uses: ./.github/actions/docker-services-setup
      env:
        # Set env vars at job level so they're available to docker-compose directly
        MINIO_ROOT_USER: "newuser"
        MINIO_ROOT_PASSWORD: "newpassword"
      with:
        docker-compose-file: "./backend/autotrader-backend/docker-compose.dev.yml"
        services: "db minio createbuckets redis" # These are service names from docker-compose
        wait-time: '120'  # Increased wait time
        db-container-name: "autotrader-backend-db-1" 
        db-user: "autotrader" 
        minio-container-name: "autotrader-backend-minio-1"
        createbuckets-container-name: "autotrader-backend-createbuckets-1"
        post-minio-ready-wait-seconds: '20'  # Increased post-ready wait time
        minio-root-user: "newuser"  # Custom MinIO user
        minio-root-password: "newpassword"  # Custom MinIO password

    # Create application configuration override for CI environment
    - name: Create application-dev.yml for CI
      working-directory: ./backend/autotrader-backend
      run: |
        echo "Creating application-dev.yml configuration for CI environment..."
        mkdir -p src/main/resources
        cat > src/main/resources/application-dev.yml << EOF
spring:
  datasource:
    url: jdbc:postgresql://localhost:5432/autotrader
    username: autotrader
    password: autotrader
  servlet:
    multipart:
      max-file-size: 10MB
      max-request-size: 10MB
  jpa:
    hibernate:
      ddl-auto: update
    properties:
      hibernate:
        dialect: org.hibernate.dialect.PostgreSQLDialect
        format_sql: true
        show_sql: true
  mail:
    host: localhost
    port: 1025
    username: admin
    password: password
minio:
  endpoint: http://localhost:9000
  accessKey: newuser
  secretKey: newpassword
  bucket: autotrader-assets
logging:
  level:
    root: INFO
    com.autotrader: DEBUG
    org.springframework.web: DEBUG
    org.hibernate: INFO
server:
  port: 8080
EOF

    # Use the composite action for Spring Boot startup
    - name: Start Spring Boot Application
      id: spring-boot
      uses: ./.github/actions/spring-boot-setup
      with:
        working-directory: "./backend/autotrader-backend"
        spring-profiles: "dev"
        debug-mode: 'true'
        wait-retries: '60'  # Increased number of retries
        wait-time: '5'     # Shorter intervals but more attempts
        health-check-path: "/actuator/health"
        
    # Capture initial logs to aid in debugging
    - name: Capture Initial Spring Boot Logs
      if: always()
      run: |
        echo "Initial Spring Boot logs (if available):"
        LOG_FILE="./backend/autotrader-backend/spring-boot.log"
        if [ -f "$LOG_FILE" ]; then
          cat "$LOG_FILE"
        else
          echo "Spring Boot log file not found at $LOG_FILE"
        fi
        
        echo "Checking application status:"
        curl -v http://localhost:8080/actuator/health || echo "Health endpoint not responding"
        echo "Checking application environment:"
        curl -v http://localhost:8080/actuator/env || true

    # Run Postman Tests with more explicit collection path
    - name: Run Postman Tests
      if: always() # Try to run the tests even if Spring Boot had issues
      uses: ./.github/actions/postman-tests
      with:
        collection-path: './backend/autotrader-backend/src/test/resources/postman/autotrader-api-collection.json'
        environment-file: './postman/test_environment.json'
        results-directory: 'results'
        auto-detect-collection: 'false'
        
    # Upload test results and logs
    - name: Upload test results and logs
      if: always()
      uses: actions/upload-artifact@v4
      with:
        name: test-artifacts
        path: |
          results/**
          ./backend/autotrader-backend/spring-boot*.log
          ./backend/autotrader-backend/build/reports/**/*

    # Generate diagnostic summary
    - name: Generate Diagnostic Summary
      if: always()
      run: |
        echo "=== Postman Tests Diagnostic Summary ==="
        echo "Date: $(date)"
        echo ""
        echo "=== Environment ==="
        echo "OS: $(uname -a)"
        echo "Java: $(java -version 2>&1 | head -n 1)"
        echo "Docker: $(docker --version)"
        echo "Docker Compose: $(docker compose version)"
        echo ""
        echo "=== Service Status ==="
        echo "Docker Containers:"
        docker ps -a
        echo ""
        echo "=== MinIO Status ==="
        if docker ps | grep -q minio; then
          echo "MinIO is running"
          docker exec autotrader-backend-minio-1 mc ls myminio || echo "Failed to list MinIO buckets"
        else
          echo "MinIO is NOT running"
        fi
        echo ""
        echo "=== Database Status ==="
        if docker ps | grep -q db; then
          echo "Database is running"
          docker exec autotrader-backend-db-1 pg_isready -U autotrader || echo "Database connection issues"
        else
          echo "Database is NOT running"
        fi
        echo ""
        echo "=== Spring Boot Status ==="
        if curl -s http://localhost:8080/actuator/health > /dev/null; then
          echo "Spring Boot is responding on health endpoint"
          curl -s http://localhost:8080/actuator/health
        else
          echo "Spring Boot is NOT responding on health endpoint"
          SPRING_PID="${{ steps.spring-boot.outputs.pid }}"
          if [ ! -z "$SPRING_PID" ] && ps -p $SPRING_PID > /dev/null; then
            echo "Process is still running with PID: $SPRING_PID"
          else
            echo "Process is NOT running"
          fi
        fi
        echo ""
        echo "=== Log File Status ==="
        if [ -f "./backend/autotrader-backend/spring-boot.log" ]; then
          LOG_SIZE=$(wc -l < ./backend/autotrader-backend/spring-boot.log)
          echo "Spring Boot log exists with $LOG_SIZE lines"
          echo "Last 10 lines of log:"
          tail -n 10 ./backend/autotrader-backend/spring-boot.log
        else
          echo "Spring Boot log file NOT found"
        fi

    # This step will always run after the tests are done, regardless of success or failure
    - name: Cleanup test environment
      if: always()
      run: |
        echo "Cleaning up test environment"
        
        # Kill the Spring Boot process if it was started using the action
        SPRING_PID="${{ steps.spring-boot.outputs.pid }}"
        if [ ! -z "$SPRING_PID" ]; then
          echo "Stopping Spring Boot application (PID: $SPRING_PID)..."
          kill $SPRING_PID || true
          echo "Spring Boot logs (full content):"
          if [ -f "./backend/autotrader-backend/spring-boot.log" ]; then
            cat ./backend/autotrader-backend/spring-boot.log
          fi
        else
          echo "No Spring Boot PID found from action output, checking running Java processes..."
          ps aux | grep "[j]ava.*autotrader" || echo "No matching Java processes found"
        fi
        
        # Stop Docker services if they were started
        if [ -f "./backend/autotrader-backend/docker-compose.dev.yml" ]; then
          echo "Stopping Docker services..."
          cd ./backend/autotrader-backend
          echo "Docker container status before shutdown:"
          docker ps -a
          docker compose -f docker-compose.dev.yml down -v
          echo "Docker container status after shutdown:"
          docker ps -a
        fi
        
        echo "Cleanup complete"
