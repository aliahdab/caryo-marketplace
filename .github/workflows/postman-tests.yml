name: Postman API Tests

on:
  workflow_dispatch:  
  pull_request:
    branches:
      - main 
  schedule:
    - cron: '0 0 * * 1'  # Run weekly on Mondays at midnight

jobs:
  api-tests:
    runs-on: ubuntu-latest
    timeout-minutes: 20  # Prevent hanging builds
    
    steps:
    - uses: actions/checkout@v4
      with:
        fetch-depth: 0
        lfs: true # Explicitly enable LFS file download

    # Verify and fix Gradle wrapper if needed (for backend builds)
    - name: Set up Gradle environment
      run: |
        echo "Setting up Gradle environment with proper permissions..."
        
        # Create a custom Gradle home directory in the workspace instead of /home/runner/.gradle
        mkdir -p $GITHUB_WORKSPACE/gradle-home
        echo "GRADLE_USER_HOME=$GITHUB_WORKSPACE/gradle-home" >> $GITHUB_ENV
        
        # Create necessary subdirectories
        mkdir -p $GITHUB_WORKSPACE/gradle-home/wrapper/dists
        mkdir -p $GITHUB_WORKSPACE/gradle-home/caches
        mkdir -p $GITHUB_WORKSPACE/gradle-home/daemon
        
        # Set full permissions on the custom Gradle home
        chmod -R 777 $GITHUB_WORKSPACE/gradle-home
        
        # List directory contents to verify setup
        echo "Checking custom Gradle home setup:"
        ls -la $GITHUB_WORKSPACE/gradle-home/
        
        echo "Custom Gradle home directory is ready at $GITHUB_WORKSPACE/gradle-home"

    - name: Verify Gradle Wrapper (if backend build is needed)
      working-directory: ./backend/autotrader-backend
      run: |
        echo "Verifying Gradle wrapper files..."
        
        # Check if JAR exists and is valid
        if [ ! -f ./gradle/wrapper/gradle-wrapper.jar ]; then
          echo "ERROR: gradle-wrapper.jar is missing."
          MISSING_JAR=true
        else
          JAR_SIZE=$(stat -c%s ./gradle/wrapper/gradle-wrapper.jar)
          echo "Current gradle-wrapper.jar size: $JAR_SIZE bytes"
          
          # Check for suspiciously small size (LFS pointer is ~130 bytes)
          if [ "$JAR_SIZE" -lt 10000 ]; then
            echo "WARNING: gradle-wrapper.jar is suspiciously small ($JAR_SIZE bytes). It might be an LFS pointer."
            echo "Content of the suspicious file:"
            cat ./gradle/wrapper/gradle-wrapper.jar
            
            # Fix the wrapper
            echo "Generating a new wrapper..."
            if command -v gradle &> /dev/null; then
              gradle wrapper --gradle-version 8.5 --distribution-type bin
            else
              echo "Downloading Gradle 8.5..."
              GRADLE_ZIP=gradle-8.5-bin.zip
              curl -L -o $GRADLE_ZIP https://services.gradle.org/distributions/gradle-8.5-bin.zip
              unzip -q -d . $GRADLE_ZIP
              chmod +x ./gradle-8.5/bin/gradle
              ./gradle-8.5/bin/gradle wrapper --gradle-version 8.5 --distribution-type bin
              rm -rf gradle-8.5 $GRADLE_ZIP
            fi
            
            # Verify new wrapper
            if [ -f ./gradle/wrapper/gradle-wrapper.jar ]; then
              NEW_SIZE=$(stat -c%s ./gradle/wrapper/gradle-wrapper.jar)
              echo "New gradle-wrapper.jar generated. Size: $NEW_SIZE bytes"
            fi
          fi
        fi
        
        # Final verification
        echo "Final verification of gradle-wrapper.jar:"
        ls -la ./gradle/wrapper/gradle-wrapper.jar || echo "gradle-wrapper.jar still missing!"
        file ./gradle/wrapper/gradle-wrapper.jar || echo "Cannot get file info"

    # Set up environment for API tests
    - name: Set up environment
      run: |
        echo "Setting up test environment"
        
        # Start Docker services if needed
        if [ -f "./backend/autotrader-backend/docker-compose.dev.yml" ]; then
          echo "Starting backend services with Docker Compose..."
          cd ./backend/autotrader-backend
          docker compose -f docker-compose.dev.yml up -d
          cd -
          
          # Wait for services to be available
          echo "Waiting for services to initialize (60 seconds)..."
          sleep 60
          
          # Check service health
          echo "Checking service health..."
          if docker ps | grep -q "db"; then
            echo "Checking PostgreSQL readiness..."
            MAX_RETRIES=15
            RETRY_COUNT=0
            while [ $RETRY_COUNT -lt $MAX_RETRIES ]; do
              if docker exec $(docker ps -q -f name=db) pg_isready -U autotrader -t 15 2>/dev/null; then
                echo "PostgreSQL is ready!"
                break
              else
                RETRY_COUNT=$((RETRY_COUNT+1))
                echo "PostgreSQL not ready yet. Attempt $RETRY_COUNT of $MAX_RETRIES"
                if [ $RETRY_COUNT -eq $MAX_RETRIES ]; then
                  echo "PostgreSQL failed to become ready. Showing logs but continuing..."
                  docker logs $(docker ps -q -f name=db)
                fi
                sleep $((RETRY_COUNT * 5))
              fi
            done
          fi
        else
          echo "No Docker Compose file found. Assuming services are already running remotely."
        fi

    # Build and start the Spring Boot backend application
    - name: Set up JDK 17
      uses: actions/setup-java@v3
      with:
        java-version: '17'
        distribution: 'temurin'
        
    - name: Build and start Spring Boot application
      working-directory: ./backend/autotrader-backend
      run: |
        echo "Building and starting Spring Boot application..."
        # Grant execute permission to gradlew
        chmod +x ./gradlew
        
        # Ensure proper permissions for project Gradle files
        echo "Setting permissions for project Gradle files..."
        chmod -R u+rwX,go+rX ./gradle
        
        # Create a gradle.properties file to enforce the custom Gradle home
        echo "org.gradle.daemon=false" > gradle.properties
        echo "org.gradle.jvmargs=-Xmx2g -XX:MaxMetaspaceSize=512m -XX:+HeapDumpOnOutOfMemoryError" >> gradle.properties
        
        echo "Using custom Gradle home: $GRADLE_USER_HOME"
        
        # Check for application.properties/yml and ensure database config is correct
        echo "Checking application configuration..."
        if [ -f "src/main/resources/application-dev.yml" ]; then
          echo "Found application-dev.yml:"
          cat src/main/resources/application-dev.yml | grep -A 10 datasource || echo "No datasource configuration found"
        elif [ -f "src/main/resources/application-dev.properties" ]; then
          echo "Found application-dev.properties:"
          cat src/main/resources/application-dev.properties | grep datasource || echo "No datasource configuration found"
        else
          echo "No application-dev config found, checking main application config..."
          if [ -f "src/main/resources/application.yml" ]; then
            cat src/main/resources/application.yml | grep -A 10 datasource || echo "No datasource configuration found"
          elif [ -f "src/main/resources/application.properties" ]; then
            cat src/main/resources/application.properties | grep datasource || echo "No datasource configuration found"
          else
            echo "WARNING: No application configuration files found!"
          fi
        fi
        
        # Try with no daemon mode first
        ./gradlew build -x test --no-daemon || {
          echo "First build attempt failed, trying with more diagnostics..."
          
          # Check if Gradle home is accessible and writable
          echo "Verifying Gradle home directory:"
          ls -la $GRADLE_USER_HOME
          touch $GRADLE_USER_HOME/test_write && echo "Write test passed" || echo "Write test failed"
          
          # Try with specific properties for troubleshooting
          echo "Retrying with debug flags..."
          ./gradlew build -x test --no-daemon --stacktrace --info
        }
        
        # Start the application in the background with dev profile and additional properties
        echo "Starting Spring Boot with enhanced debugging..."
        nohup ./gradlew bootRun --no-daemon \
          --args='--spring.profiles.active=dev --debug --logging.level.root=DEBUG --logging.level.org.springframework=DEBUG' \
          > spring-boot.log 2>&1 &
        
        # Store the PID for later cleanup
        echo "SPRING_PID=$!" >> $GITHUB_ENV
        
        echo "Spring Boot application started with PID: $!"
        
        # Show initial log output to help with debugging
        sleep 5
        echo "Initial Spring Boot startup log (first 20 lines):"
        head -n 20 spring-boot.log || true
        
        # Wait for Spring Boot to become ready with enhanced diagnostics
        echo "Waiting for Spring Boot application to become ready..."
        MAX_RETRIES=45  # Increased from 30 to give more time
        RETRY_COUNT=0
        while [ $RETRY_COUNT -lt $MAX_RETRIES ]; do
          echo "Checking Spring Boot health (attempt $((RETRY_COUNT+1))/$MAX_RETRIES)..."
          
          # Check process is still running
          if ! ps -p $SPRING_PID > /dev/null; then
            echo "ERROR: Spring Boot process is not running anymore! Checking logs..."
            cat spring-boot.log
            echo "Attempting to restart the application..."
            nohup ./gradlew bootRun --no-daemon --args='--spring.profiles.active=dev --debug' > spring-boot.log 2>&1 &
            echo "SPRING_PID=$!" >> $GITHUB_ENV
            echo "New process started with PID: $!"
            sleep 10
            continue
          fi
          
          # Try different health endpoints with verbose output
          HEALTH_CHECK=$(curl -v http://localhost:8080/actuator/health 2>&1)
          if echo "$HEALTH_CHECK" | grep -q "UP"; then
            echo "Spring Boot application is ready! (via actuator)"
            break
          fi
          
          echo "Actuator health check response:"
          echo "$HEALTH_CHECK" | tail -n 10
          
          OTHER_CHECK=$(curl -v http://localhost:8080/ 2>&1)
          if echo "$OTHER_CHECK" | grep -q "HTTP/1.1 200\|HTTP/1.1 302"; then
            echo "Spring Boot application is ready! (via root path)"
            break
          fi
          
          # Show current log state periodically
          if [ $((RETRY_COUNT % 5)) -eq 0 ]; then
            echo "Current Spring Boot log tail:"
            tail -n 20 spring-boot.log
            echo "Checking if server is listening on port 8080..."
            netstat -tulpn 2>/dev/null | grep 8080 || echo "No process listening on port 8080"
          fi
          
          RETRY_COUNT=$((RETRY_COUNT+1))
          if [ $RETRY_COUNT -eq $MAX_RETRIES ]; then
            echo "Spring Boot application failed to become ready in time."
            echo "Full application log:"
            cat spring-boot.log
            echo "Continuing anyway to see if the tests can connect..."
          fi
          sleep 10
        done

    - name: Install Newman
      run: npm install -g newman newman-reporter-htmlextra

    - name: Create Results Directory
      run: mkdir -p results

    - name: Verify API is Accessible
      run: |
        echo "Performing final API verification before running tests..."
        # Try to connect to the API and display detailed information
        curl -v http://localhost:8080/ || echo "Failed to connect to root endpoint"
        
        # Check if network is properly set up
        echo "Network configuration:"
        ip addr show || ifconfig || echo "Network tools not available"
        
        echo "Listening ports:"
        netstat -tulpn || ss -tulwn || echo "Network tools not available"
        
        # Ensure Docker containers are running
        echo "Docker containers status:"
        docker ps
        
        # Check if we can connect to the database from the host
        echo "Testing database connection from host:"
        docker exec $(docker ps -q -f name=db) pg_isready -h localhost -U autotrader || echo "Cannot connect to database from host"

    - name: Prepare Environment File
      run: |
        echo "Checking and preparing Postman environment file..."
        if [ -f "./postman/test_environment.json" ]; then
          # Make a backup of the original file
          cp ./postman/test_environment.json ./postman/test_environment.json.bak
          
          # Update the environment file to ensure localhost URL is correct
          echo "Ensuring API URL is correctly set to localhost:8080..."
          cat ./postman/test_environment.json | grep -i url || echo "No URL found in environment file"
          
          # Update the file to ensure proper localhost URL
          sed -i 's|"value": "http://[^/]*|"value": "http://localhost:8080|g' ./postman/test_environment.json
          
          echo "Updated environment file:"
          cat ./postman/test_environment.json | grep -i url
        else
          echo "WARNING: test_environment.json not found in ./postman/"
          echo "Searching for environment files:"
          find . -name "*environment*.json" -o -name "*env*.json"
        fi

    - name: Run Postman Collection
      run: |
        echo "Running Postman collection tests..."
        # Determine which collection file to use
        if [ -f "./postman/Caryo_Marketplace_API_Tests.json" ]; then
          COLLECTION_PATH="./postman/Caryo_Marketplace_API_Tests.json"
          echo "Using Caryo_Marketplace_API_Tests.json collection file"
        elif [ -f "./backend/autotrader-backend/src/test/resources/postman/autotrader-api-collection.json" ]; then
          COLLECTION_PATH="./backend/autotrader-backend/src/test/resources/postman/autotrader-api-collection.json"
          echo "Using autotrader-api-collection.json collection file"
        else
          echo "ERROR: Postman collection file not found"
          echo "Searching for collection files in project..."
          find . -name "*.json" | grep -i -E "collection|postman|api[-_]test"
          exit 1
        fi
        
        # Run newman with enhanced timeout and verbose logging
        echo "Running Newman with verbose output..."
        newman run "$COLLECTION_PATH" \
          --environment ./postman/test_environment.json \
          --timeout-request 60000 \
          --timeout 120000 \
          --reporters cli,junit,htmlextra \
          --reporter-junit-export results/junit-report.xml \
          --reporter-htmlextra-export results/html-report.html \
          --verbose

    - name: Upload test results
      if: always()
      uses: actions/upload-artifact@v4
      with:
        name: postman-test-results
        path: results/

    # Cleanup test environment if needed
    - name: Cleanup
      if: always()
      run: |
        echo "Cleaning up test environment"
        
        # Stop Spring Boot application if it was started
        if [ ! -z "$SPRING_PID" ]; then
          echo "Stopping Spring Boot application (PID: $SPRING_PID)..."
          kill $SPRING_PID || true
          echo "Spring Boot logs (last 50 lines):"
          if [ -f "./backend/autotrader-backend/spring-boot.log" ]; then
            tail -n 50 ./backend/autotrader-backend/spring-boot.log
          fi
        fi
        
        # Stop Docker services if they were started
        if [ -f "./backend/autotrader-backend/docker-compose.dev.yml" ]; then
          echo "Stopping Docker services..."
          cd ./backend/autotrader-backend
          docker compose -f docker-compose.dev.yml down -v
          cd -
        fi
        echo "Cleanup complete"
