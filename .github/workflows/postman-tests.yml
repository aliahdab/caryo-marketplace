name: Postman API Tests (Standalone)

on:
  workflow_dispatch:
  pull_request:
    branches:
      - develop # Run on PRs targeting develop branch
      - main # Also run on PRs targeting main branch
    paths:
      - 'backend/autotrader-backend/**'
      - '.github/workflows/postman-tests.yml'
      - '.github/actions/docker-services-setup/**'
      - '.github/actions/gradle-setup/**'
      - '.github/actions/spring-boot-setup/**'
      - '.github/actions/postman-tests/**'
      - 'postman/**'
  schedule:
    - cron: '0 0 * * 1'  # Run weekly on Mondays at midnight

jobs:
  api-tests:
    runs-on: ubuntu-latest
    timeout-minutes: 30  # Increased timeout to prevent hanging builds

    steps:
    - uses: actions/checkout@v4
      with:
        fetch-depth: 0
        lfs: true # Explicitly enable LFS file download
        
    # Setup Gradle Environment
    - name: Setup Gradle Environment
      uses: ./.github/actions/gradle-setup
      with:
        working-directory: "./backend/autotrader-backend"
        java-version: "17"
        gradle-version: "8.5"
        cache: true
        
    # Ensure Gradle Wrapper exists
    - name: Ensure Gradle Wrapper
      working-directory: ./backend/autotrader-backend
      run: |
        echo "Checking for Gradle wrapper files..."
        if [ ! -f "./gradlew" ]; then
          echo "gradlew script not found! Generating a new one..."
          
          # First try to use the Gradle CLI if available
          if command -v gradle &> /dev/null; then
            echo "Using gradle CLI to generate wrapper"
            gradle wrapper --gradle-version=8.5
          elif [ -f "../gradle/wrapper/gradle-wrapper.jar" ]; then
            echo "Copying Gradle wrapper from parent directory"
            mkdir -p ./gradle/wrapper/
            cp ../gradle/wrapper/gradle-wrapper.jar ./gradle/wrapper/
            cp ../gradle/wrapper/gradle-wrapper.properties ./gradle/wrapper/
            cp ../gradlew ./
            cp ../gradlew.bat ./
            chmod +x ./gradlew
          else
            # Additional fallback - try to find wrapper elsewhere in the repo
            echo "Searching for Gradle wrapper elsewhere in the repository..."
            WRAPPER_JAR=$(find $(pwd) -name "gradle-wrapper.jar" | head -n 1)
            if [ ! -z "$WRAPPER_JAR" ]; then
              echo "Found Gradle wrapper at $WRAPPER_JAR"
              WRAPPER_DIR=$(dirname "$WRAPPER_JAR")
              mkdir -p ./gradle/wrapper/
              cp "$WRAPPER_JAR" ./gradle/wrapper/
              cp "$WRAPPER_DIR/gradle-wrapper.properties" ./gradle/wrapper/ || echo "No properties file found, may need manual configuration"
              
              # Look for gradlew script in the same directory
              GRADLEW_DIR=$(dirname $(dirname "$WRAPPER_DIR"))
              if [ -f "$GRADLEW_DIR/gradlew" ]; then
                cp "$GRADLEW_DIR/gradlew" ./
                cp "$GRADLEW_DIR/gradlew.bat" ./ || echo "No gradlew.bat found"
                chmod +x ./gradlew
              else
                # Create a basic gradlew script as last resort
                echo "Creating a basic gradlew script..."
                echo '#!/bin/sh
CLASSPATH=$APP_HOME/gradle/wrapper/gradle-wrapper.jar
exec java -classpath "$CLASSPATH" org.gradle.wrapper.GradleWrapperMain "$@"' > ./gradlew
                chmod +x ./gradlew
              fi
            else
              echo "ERROR: Could not generate or find Gradle wrapper!"
              echo "Current directory structure:"
              ls -la ./
              echo "Parent directory structure:"
              ls -la ../
              exit 1
            fi
          fi
        fi
        
        echo "Verifying gradlew exists and is executable:"
        if [ -f "./gradlew" ]; then
          ls -la ./gradlew
          echo "Ensuring gradlew is executable"
          chmod +x ./gradlew
        else
          echo "ERROR: gradlew still not found after attempt to generate/copy!"
          exit 1
        fi
        
    # Setup Docker Services
    - name: Setup Docker Services
      uses: ./.github/actions/docker-services-setup
      env:
        # Set env vars at job level so they're available to docker-compose directly
        MINIO_ROOT_USER: "newuser"
        MINIO_ROOT_PASSWORD: "newpassword"
      with:
        docker-compose-file: "./backend/autotrader-backend/docker-compose.dev.yml"
        services: "db minio createbuckets redis" # These are service names from docker-compose
        wait-time: '120'  # Increased wait time
        db-container-name: "autotrader-backend-db-1" 
        db-user: "autotrader" 
        minio-container-name: "autotrader-backend-minio-1"
        createbuckets-container-name: "autotrader-backend-createbuckets-1"
        post-minio-ready-wait-seconds: '20'  # Increased post-ready wait time
        minio-root-user: "newuser"  # Custom MinIO user
        minio-root-password: "newpassword"  # Custom MinIO password

    # Verify Docker services are running correctly
    - name: Verify Docker Services
      run: |
        echo "Verifying Docker services are running correctly..."
        docker ps
        
        echo "Checking database connection..."
        docker exec autotrader-backend-db-1 pg_isready -U autotrader || echo "Database connection issues detected"
        
        echo "Checking MinIO service..."
        curl -s -I http://localhost:9000 || echo "MinIO service not responding"
        
        echo "Checking Redis service..."
        docker exec autotrader-backend-redis-1 redis-cli ping || echo "Redis service not responding"
        
        echo "Checking environment variables..."
        env | grep -E 'MINIO|POSTGRES|REDIS|SPRING' || echo "No matching environment variables found"

    # Create application configuration override for CI environment
    - name: Create application-dev.yml for CI
      working-directory: ./backend/autotrader-backend
      run: |
        echo "Creating application-dev.yml configuration for CI environment..."
        mkdir -p src/main/resources
        cat > src/main/resources/application-dev.yml <<EOL
spring:
  datasource:
    url: jdbc:postgresql://localhost:5432/autotrader
    username: autotrader
    password: autotrader
  servlet:
    multipart:
      max-file-size: 10MB
      max-request-size: 10MB
  jpa:
    hibernate:
      ddl-auto: update
    properties:
      hibernate:
        dialect: org.hibernate.dialect.PostgreSQLDialect
        format_sql: true
        show_sql: true
  mail:
    host: localhost
    port: 1025
    username: admin
    password: password
minio:
  endpoint: http://localhost:9000
  accessKey: newuser
  secretKey: newpassword
  bucket: autotrader-assets
logging:
  level:
    root: INFO
    com.autotrader: DEBUG
    org.springframework.web: DEBUG
    org.hibernate: INFO
server:
  port: 8080
EOL
        echo "Created application-dev.yml:"
        cat src/main/resources/application-dev.yml

    # Use the composite action for Spring Boot startup
    - name: Start Spring Boot Application
      id: spring-boot
      uses: ./.github/actions/spring-boot-setup
      with:
        working-directory: "./backend/autotrader-backend"
        spring-profiles: "dev"
        debug-mode: 'true'
        wait-retries: '60'  # Increased number of retries
        wait-time: '5'     # Shorter intervals but more attempts
        health-check-path: "/actuator/health"
        
    # Capture initial logs to aid in debugging
    - name: Capture Initial Spring Boot Logs
      if: always()
      run: |
        echo "Initial Spring Boot logs (if available):"
        LOG_FILE="./backend/autotrader-backend/spring-boot.log"
        if [ -f "$LOG_FILE" ]; then
          cat "$LOG_FILE"
        else
          echo "Spring Boot log file not found at $LOG_FILE"
        fi
        
        echo "Checking application status:"
        curl -v http://localhost:8080/actuator/health || echo "Health endpoint not responding"
        echo "Checking application environment:"
        curl -v http://localhost:8080/actuator/env || true

    # Run Postman Tests with more explicit collection path
    - name: Run Postman Tests
      if: always() # Try to run the tests even if Spring Boot had issues
      uses: ./.github/actions/postman-tests
      with:
        collection-path: './backend/autotrader-backend/src/test/resources/postman/autotrader-api-collection.json'
        environment-file: './postman/test_environment.json'
        results-directory: 'results'
        auto-detect-collection: 'false'
        
    # Upload test results
    - name: Upload test results
      if: always()
      uses: actions/upload-artifact@v4
      with:
        name: postman-test-results
        path: results/**
        
    # Upload Spring Boot logs separately
    - name: Upload Spring Boot logs
      if: always()
      uses: actions/upload-artifact@v4
      with:
        name: spring-boot-logs
        path: |
          ./backend/autotrader-backend/spring-boot*.log
          ./backend/autotrader-backend/build/reports/**/*

    # This step will always run after the tests are done, regardless of success or failure
    - name: Cleanup test environment
      if: always()
      run: |
        echo "Cleaning up test environment"
        
        # Kill the Spring Boot process if it was started using the action
        SPRING_PID="${{ steps.spring-boot.outputs.pid }}"
        if [ ! -z "$SPRING_PID" ]; then
          echo "Stopping Spring Boot application (PID: $SPRING_PID)..."
          kill $SPRING_PID || true
          echo "Spring Boot logs (full content):"
          if [ -f "./backend/autotrader-backend/spring-boot.log" ]; then
            cat ./backend/autotrader-backend/spring-boot.log
          fi
        else
          echo "No Spring Boot PID found from action output, checking running Java processes..."
          ps aux | grep "[j]ava.*autotrader" || echo "No matching Java processes found"
        fi
        
        # Stop Docker services if they were started
        if [ -f "./backend/autotrader-backend/docker-compose.dev.yml" ]; then
          echo "Stopping Docker services..."
          cd ./backend/autotrader-backend
          echo "Docker container status before shutdown:"
          docker ps -a
          docker compose -f docker-compose.dev.yml down -v
          echo "Docker container status after shutdown:"
          docker ps -a
        fi
        
        echo "Cleanup complete"
