package com.autotrader.autotraderbackend.service;

import com.autotrader.autotraderbackend.exception.ResourceNotFoundException;
<<<<<<< HEAD
import com.autotrader.autotraderbackend.events.ListingApprovedEvent;
import com.autotrader.autotraderbackend.events.ListingArchivedEvent;
import com.autotrader.autotraderbackend.events.ListingExpiredEvent;
import com.autotrader.autotraderbackend.events.ListingMarkedAsSoldEvent;
=======
>>>>>>> a7fbdc3 (Add unit tests for CarListingStatusService methods to ensure proper functionality and error handling)
import com.autotrader.autotraderbackend.mapper.CarListingMapper;
import com.autotrader.autotraderbackend.model.CarListing;
import com.autotrader.autotraderbackend.model.User;
import com.autotrader.autotraderbackend.payload.response.CarListingResponse;
import com.autotrader.autotraderbackend.repository.CarListingRepository;
import com.autotrader.autotraderbackend.repository.UserRepository;
<<<<<<< HEAD
import jakarta.validation.constraints.NotNull;
import lombok.NonNull;
=======
import com.autotrader.autotraderbackend.events.ListingApprovedEvent;
import com.autotrader.autotraderbackend.events.ListingArchivedEvent;
import com.autotrader.autotraderbackend.events.ListingMarkedAsSoldEvent;
>>>>>>> a7fbdc3 (Add unit tests for CarListingStatusService methods to ensure proper functionality and error handling)
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.context.ApplicationEventPublisher;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
<<<<<<< HEAD
import org.springframework.validation.annotation.Validated;

import java.util.Objects;

/**
 * Service responsible for managing the status of car listings.
 * This includes operations like marking listings as sold, approving listings,
 * pausing/resuming listings, and archiving/unarchiving listings.
 *
 * All operations are transactional and properly validated.
 * Status changes trigger appropriate events for system-wide consistency.
 *
 * @author AutoTrader Team
 * @version 2.0
 * @since 2025-05-20
 */
@Slf4j
@Service
@Validated
@RequiredArgsConstructor
=======

import java.util.Objects;

@Service
@RequiredArgsConstructor
@Slf4j
>>>>>>> a7fbdc3 (Add unit tests for CarListingStatusService methods to ensure proper functionality and error handling)
public class CarListingStatusService {

    private final CarListingRepository carListingRepository;
    private final UserRepository userRepository;
    private final CarListingMapper carListingMapper;
    private final ApplicationEventPublisher eventPublisher;

<<<<<<< HEAD
    /**
     * Marks a car listing as sold by its owner.
     * 
     * @param listingId The ID of the listing to mark as sold
     * @param username The username of the user attempting to mark the listing as sold
     * @return Updated car listing response
     * @throws ResourceNotFoundException if the listing or user is not found
     * @throws SecurityException if the user is not authorized to modify the listing
     * @throws IllegalStateException if the listing is already sold or archived
     */
    @Transactional
    public CarListingResponse markListingAsSold(@NonNull Long listingId, @NonNull String username) {
        Objects.requireNonNull(listingId, "Listing ID must not be null");
        Objects.requireNonNull(username, "Username must not be null");

        User user = findUserByUsername(username);
        CarListing listing = findListingById(listingId);
        
        authorizeListingModification(listing, user, "mark as sold");
        validateListingCanBeMarkedAsSold(listing);

        listing.setSold(true);
        CarListing savedListing = carListingRepository.save(listing);
        eventPublisher.publishEvent(new ListingMarkedAsSoldEvent(this, savedListing, false));
        
        log.info("Listing {} marked as sold by user {}", listingId, username);
        return carListingMapper.toCarListingResponse(savedListing);
    }

    /**
     * Marks a car listing as sold by an admin.
     *
     * @param listingId The ID of the listing to mark as sold
     * @return Updated car listing response with admin-specific fields
     * @throws ResourceNotFoundException if the listing is not found
     * @throws IllegalStateException if the listing is already sold or archived
     */
    @Transactional
    public CarListingResponse markListingAsSoldByAdmin(@NonNull Long listingId) {
        Objects.requireNonNull(listingId, "Listing ID must not be null");

        CarListing listing = findListingById(listingId);
        validateListingCanBeMarkedAsSold(listing);

        listing.setSold(true);
        CarListing savedListing = carListingRepository.save(listing);
        eventPublisher.publishEvent(new ListingMarkedAsSoldEvent(this, savedListing, true));
        
        log.info("Listing {} marked as sold by admin", listingId);
        return carListingMapper.toCarListingResponseForAdmin(savedListing);
    }

    /**
     * Approves a car listing
     *
     * @param listingId The ID of the listing to approve
     * @return Updated car listing response
     * @throws ResourceNotFoundException if the listing is not found
     * @throws IllegalStateException if the listing is already approved
     */
    @Transactional
    public CarListingResponse approveListing(@NonNull Long listingId) {
        Objects.requireNonNull(listingId, "Listing ID must not be null");

        CarListing listing = findListingById(listingId);
        validateListingCanBeApproved(listing);

        listing.setApproved(true);
        CarListing savedListing = carListingRepository.save(listing);
        eventPublisher.publishEvent(new ListingApprovedEvent(this, savedListing));
        
        log.info("Listing {} approved", listingId);
        return carListingMapper.toCarListingResponse(savedListing);
    }

    /**
     * Temporarily pauses (hides) a car listing from public view.
     *
     * @param listingId The ID of the listing to pause
     * @param username The username of the user attempting to pause the listing
     * @return Updated car listing response
     * @throws ResourceNotFoundException if the listing or user is not found
     * @throws SecurityException if the user is not authorized to modify the listing
     * @throws IllegalStateException if the listing is already paused, sold, or archived
     */
    @Transactional
    public CarListingResponse pauseListing(@NonNull Long listingId, @NonNull String username) {
        Objects.requireNonNull(listingId, "Listing ID must not be null");
        Objects.requireNonNull(username, "Username must not be null");

        User user = findUserByUsername(username);
        CarListing listing = findListingById(listingId);
        
        authorizeListingModification(listing, user, "pause");
        validateListingCanBePaused(listing);

        listing.setIsUserActive(false);
        CarListing savedListing = carListingRepository.save(listing);
        
        log.info("Listing {} paused by user {}", listingId, username);
        return carListingMapper.toCarListingResponse(savedListing);
    }

    /**
     * Resumes (unhides) a paused car listing, making it visible in public view again.
     *
     * @param listingId The ID of the listing to resume
     * @param username The username of the user attempting to resume the listing
     * @return Updated car listing response
     * @throws ResourceNotFoundException if the listing or user is not found
     * @throws SecurityException if the user is not authorized to modify the listing
     * @throws IllegalStateException if the listing is already active, sold, or archived
     */
    @Transactional
    public CarListingResponse resumeListing(@NonNull Long listingId, @NonNull String username) {
        Objects.requireNonNull(listingId, "Listing ID must not be null");
        Objects.requireNonNull(username, "Username must not be null");

        User user = findUserByUsername(username);
        CarListing listing = findListingById(listingId);
        
        authorizeListingModification(listing, user, "resume");
        validateListingCanBeResumed(listing);

        listing.setIsUserActive(true);
        CarListing savedListing = carListingRepository.save(listing);
        
        log.info("Listing {} resumed by user {}", listingId, username);
        return carListingMapper.toCarListingResponse(savedListing);
    }

    /**
     * Archives a car listing by its owner. Archived listings are hidden from public view
     * and cannot be modified without being unarchived first.
     *
     * @param listingId The ID of the listing to archive
     * @param username The username of the user attempting to archive the listing
     * @return Updated car listing response
     * @throws ResourceNotFoundException if the listing or user is not found
     * @throws SecurityException if the user is not authorized to modify the listing
     * @throws IllegalStateException if the listing is already archived
     */
    @Transactional
    public CarListingResponse archiveListing(@NonNull Long listingId, @NonNull String username) {
        Objects.requireNonNull(listingId, "Listing ID must not be null");
        Objects.requireNonNull(username, "Username must not be null");

        User user = findUserByUsername(username);
        CarListing listing = findListingById(listingId);
        
        authorizeListingModification(listing, user, "archive");
        validateListingCanBeArchived(listing);

        listing.setArchived(true);
        CarListing savedListing = carListingRepository.save(listing);
        eventPublisher.publishEvent(new ListingArchivedEvent(this, savedListing, false));
        
        log.info("Listing {} archived by user {}", listingId, username);
        return carListingMapper.toCarListingResponse(savedListing);
    }

    /**
     * Archives a car listing by an admin. Archived listings are hidden from public view
     * and cannot be modified without being unarchived first.
     *
     * @param listingId The ID of the listing to archive
     * @return Updated car listing response with admin-specific fields
     * @throws ResourceNotFoundException if the listing is not found
     * @throws IllegalStateException if the listing is already archived
     */
    @Transactional
    public CarListingResponse archiveListingByAdmin(@NonNull Long listingId) {
        Objects.requireNonNull(listingId, "Listing ID must not be null");

        CarListing listing = findListingById(listingId);
        validateListingCanBeArchived(listing);

        listing.setArchived(true);
        CarListing savedListing = carListingRepository.save(listing);
        eventPublisher.publishEvent(new ListingArchivedEvent(this, savedListing, true));
        
        log.info("Listing {} archived by admin", listingId);
        return carListingMapper.toCarListingResponseForAdmin(savedListing);
    }

    /**
     * Unarchives a car listing by its owner. Makes the listing visible and modifiable again.
     *
     * @param listingId The ID of the listing to unarchive
     * @param username The username of the user attempting to unarchive the listing
     * @return Updated car listing response
     * @throws ResourceNotFoundException if the listing or user is not found
     * @throws SecurityException if the user is not authorized to modify the listing
     * @throws IllegalStateException if the listing is not archived
     */
    @Transactional
    public CarListingResponse unarchiveListing(@NonNull Long listingId, @NonNull String username) {
        Objects.requireNonNull(listingId, "Listing ID must not be null");
        Objects.requireNonNull(username, "Username must not be null");

        User user = findUserByUsername(username);
        CarListing listing = findListingById(listingId);
        
        authorizeListingModification(listing, user, "unarchive");
        validateListingCanBeUnarchived(listing);

        listing.setArchived(false);
        CarListing savedListing = carListingRepository.save(listing);
        
        log.info("Listing {} unarchived by user {}", listingId, username);
        return carListingMapper.toCarListingResponse(savedListing);
    }

    /**
     * Unarchives a car listing by an admin. Makes the listing visible and modifiable again.
     *
     * @param listingId The ID of the listing to unarchive
     * @return Updated car listing response with admin-specific fields
     * @throws ResourceNotFoundException if the listing is not found
     * @throws IllegalStateException if the listing is not archived
     */
    @Transactional
    public CarListingResponse unarchiveListingByAdmin(@NonNull Long listingId) {
        Objects.requireNonNull(listingId, "Listing ID must not be null");

        CarListing listing = findListingById(listingId);
        validateListingCanBeUnarchived(listing);

        listing.setArchived(false);
        CarListing savedListing = carListingRepository.save(listing);
        
        log.info("Listing {} unarchived by admin", listingId);
        return carListingMapper.toCarListingResponseForAdmin(savedListing);
    }

    /**
     * Marks a car listing as expired. This is typically called by the system
     * when a listing reaches its expiration date.
     *
     * @param listingId The ID of the listing to expire
     * @return Updated car listing response with admin-specific fields since this is a system action
     * @throws ResourceNotFoundException if the listing is not found
     * @throws IllegalStateException if the listing is already expired, sold, or archived
     */
    @Transactional
    public CarListingResponse expireListing(@NonNull Long listingId) {
        Objects.requireNonNull(listingId, "Listing ID must not be null");

        CarListing listing = findListingById(listingId);
        validateListingCanBeExpired(listing);

        listing.setExpired(true);
        CarListing savedListing = carListingRepository.save(listing);
        eventPublisher.publishEvent(new ListingExpiredEvent(this, savedListing, true));
        
        log.info("Listing {} has expired", listingId);
        return carListingMapper.toCarListingResponseForAdmin(savedListing);
    }

    private void validateListingCanBeExpired(@NonNull CarListing listing) {
        if (Boolean.TRUE.equals(listing.getExpired())) {
            throw new IllegalStateException(String.format("Listing with ID %d is already expired.", listing.getId()));
        }
        if (Boolean.TRUE.equals(listing.getSold())) {
            throw new IllegalStateException("Cannot expire a listing that has been marked as sold.");
        }
        if (Boolean.TRUE.equals(listing.getArchived())) {
            throw new IllegalStateException("Cannot expire a listing that has been archived.");
        }
    }

    // Helper methods

    /**
     * Finds a user by their username.
     *
     * @param username The username to look up
     * @return The user if found
     * @throws ResourceNotFoundException if no user is found with the given username
     */
    protected User findUserByUsername(@NonNull String username) {
        return userRepository.findByUsername(username)
                .orElseThrow(() -> new ResourceNotFoundException("User", "username", username));
    }

    /**
     * Finds a car listing by its ID.
     *
     * @param id The ID to look up
     * @return The car listing if found
     * @throws ResourceNotFoundException if no listing is found with the given ID
     */
    protected CarListing findListingById(@NonNull Long id) {
        return carListingRepository.findById(id)
                .orElseThrow(() -> new ResourceNotFoundException("CarListing", "id", id));
    }

    /**
     * Verifies that a user has permission to modify a listing.
     * Currently, this checks if the user is the seller of the listing.
     *
     * @param listing The listing to check
     * @param user The user attempting the modification
     * @param action Description of the action being attempted (for logging)
     * @throws SecurityException if the user does not have permission
     */
    protected void authorizeListingModification(@NonNull CarListing listing, @NonNull User user, String action) {
        if (!Objects.equals(listing.getSeller().getId(), user.getId())) {
=======
    // --- Helper Methods (moved from CarListingService, now public) ---

    public User findUserByUsername(String username) {
        Objects.requireNonNull(username, "Username cannot be null");
        return userRepository.findByUsername(username)
                .orElseThrow(() -> {
                    log.warn("User lookup failed for username: {}", username);
                    return new ResourceNotFoundException("User", "username", username);
                });
    }

    public CarListing findListingById(Long listingId) {
        Objects.requireNonNull(listingId, "Listing ID cannot be null");
        return carListingRepository.findById(listingId)
                .orElseThrow(() -> {
                    log.warn("CarListing lookup failed for ID: {}", listingId);
                    return new ResourceNotFoundException("CarListing", "id", listingId);
                });
    }

    public void authorizeListingModification(CarListing listing, User user, String action) {
        Objects.requireNonNull(listing, "CarListing cannot be null for authorization");
        Objects.requireNonNull(user, "User cannot be null for authorization");
        Objects.requireNonNull(action, "Action cannot be null for authorization");

        if (Objects.isNull(listing.getSeller()) || !listing.getSeller().getId().equals(user.getId())) {
            log.warn("Authorization failed: User '{}' (ID: {}) attempted to {} listing ID {} owned by '{}' (ID: {})",
                    user.getUsername(), user.getId(), action, listing.getId(),
                    Objects.nonNull(listing.getSeller()) ? listing.getSeller().getUsername() : "unknown",
                    Objects.nonNull(listing.getSeller()) ? listing.getSeller().getId() : "unknown");
>>>>>>> a7fbdc3 (Add unit tests for CarListingStatusService methods to ensure proper functionality and error handling)
            throw new SecurityException("User does not have permission to modify this listing.");
        }
    }

<<<<<<< HEAD
    // Validation methods

    private void validateListingCanBeMarkedAsSold(@NonNull CarListing listing) {
        if (Boolean.TRUE.equals(listing.getSold())) {
            throw new IllegalStateException(String.format("Listing with ID %d is already marked as sold.", listing.getId()));
        }
        if (Boolean.TRUE.equals(listing.getArchived())) {
            throw new IllegalStateException("Cannot mark an archived listing as sold. Please unarchive first.");
        }
    }

    private void validateListingCanBeApproved(@NonNull CarListing listing) {
        if (Boolean.TRUE.equals(listing.getApproved())) {
            throw new IllegalStateException(String.format("Listing with ID %d is already approved.", listing.getId()));
        }
    }

    private void validateListingCanBePaused(@NonNull CarListing listing) {
        if (Boolean.FALSE.equals(listing.getIsUserActive())) {
            throw new IllegalStateException(String.format("Listing with ID %d is already paused.", listing.getId()));
        }
        if (Boolean.TRUE.equals(listing.getSold())) {
            throw new IllegalStateException("Cannot pause a listing that has been marked as sold.");
        }
        if (Boolean.TRUE.equals(listing.getArchived())) {
            throw new IllegalStateException("Cannot pause a listing that has been archived.");
        }
    }

    private void validateListingCanBeResumed(@NonNull CarListing listing) {
        if (Boolean.TRUE.equals(listing.getIsUserActive())) {
            throw new IllegalStateException(String.format("Listing with ID %d is already active.", listing.getId()));
        }
        if (Boolean.TRUE.equals(listing.getSold())) {
            throw new IllegalStateException("Cannot resume a listing that has been marked as sold.");
        }
        if (Boolean.TRUE.equals(listing.getArchived())) {
            throw new IllegalStateException("Cannot resume a listing that has been archived. Please contact support or renew if applicable.");
        }
    }

    private void validateListingCanBeArchived(@NonNull CarListing listing) {
        if (Boolean.TRUE.equals(listing.getArchived())) {
            throw new IllegalStateException(String.format("Listing with ID %d is already archived.", listing.getId()));
        }
    }

    private void validateListingCanBeUnarchived(@NonNull CarListing listing) {
        if (Boolean.FALSE.equals(listing.getArchived())) {
            throw new IllegalStateException(String.format("Listing with ID %d is not archived.", listing.getId()));
        }
=======
    // This method can remain private as it's only used internally by other public methods in this service.
    private CarListing findListingByIdAndAuthorize(Long listingId, String username, String action) {
        User user = findUserByUsername(username);
        CarListing listing = findListingById(listingId);
        authorizeListingModification(listing, user, action);
        return listing;
    }

    // --- Status Transition Methods ---

    @Transactional
    public CarListingResponse approveListing(Long id) {
        log.info("Attempting to approve listing with ID: {}", id);
        CarListing carListing = findListingById(id);

        if (Boolean.TRUE.equals(carListing.getApproved())) {
            log.warn("Listing ID {} is already approved. No action taken.", id);
            throw new IllegalStateException("Listing with ID " + id + " is already approved.");
        }

        carListing.setApproved(true);
        CarListing approvedListing = carListingRepository.save(carListing);
        log.info("Successfully approved listing ID: {}", approvedListing.getId());

        eventPublisher.publishEvent(new ListingApprovedEvent(this, approvedListing));
        log.info("Published ListingApprovedEvent for listing ID: {}", approvedListing.getId());

        return carListingMapper.toCarListingResponse(approvedListing);
    }

    @Transactional
    public CarListingResponse pauseListing(Long listingId, String username) {
        log.info("User {} attempting to pause listing ID {}", username, listingId);
        CarListing listing = findListingByIdAndAuthorize(listingId, username, "pause");

        if (!Boolean.TRUE.equals(listing.getApproved())) {
            log.warn("User {} attempted to pause unapproved listing ID {}", username, listingId);
            throw new IllegalStateException("Cannot pause a listing that is not yet approved.");
        }
        if (Boolean.TRUE.equals(listing.getSold())) {
            log.warn("User {} attempted to pause sold listing ID {}", username, listingId);
            throw new IllegalStateException("Cannot pause a listing that has been marked as sold.");
        }
        if (Boolean.TRUE.equals(listing.getArchived())) {
            log.warn("User {} attempted to pause archived listing ID {}", username, listingId);
            throw new IllegalStateException("Cannot pause a listing that has been archived.");
        }
        if (!Boolean.TRUE.equals(listing.getIsUserActive())) { // Check if already paused
            log.warn("Listing ID {} is already paused by user {}. Throwing IllegalStateException.", listingId, username);
            throw new IllegalStateException("Listing with ID " + listingId + " is already paused.");
        }

        listing.setIsUserActive(false);
        CarListing updatedListing = carListingRepository.save(listing);
        log.info("Successfully paused listing ID {} by user {}", listingId, username);
        return carListingMapper.toCarListingResponse(updatedListing);
    }

    @Transactional
    public CarListingResponse resumeListing(Long listingId, String username) {
        log.info("User {} attempting to resume listing ID {}", username, listingId);
        CarListing listing = findListingByIdAndAuthorize(listingId, username, "resume");

        if (Boolean.TRUE.equals(listing.getSold())) {
            log.warn("User {} attempted to resume sold listing ID {}", username, listingId);
            throw new IllegalStateException("Cannot resume a listing that has been marked as sold.");
        }
        if (Boolean.TRUE.equals(listing.getArchived())) {
            log.warn("User {} attempted to resume archived listing ID {}", username, listingId);
            throw new IllegalStateException("Cannot resume a listing that has been archived. Please contact support or renew if applicable.");
        }
        if (Boolean.TRUE.equals(listing.getIsUserActive())) { // Check if already active
            log.warn("Listing ID {} is already active for user {}. Throwing IllegalStateException.", listingId, username);
            throw new IllegalStateException("Listing with ID " + listingId + " is already active.");
        }

        listing.setIsUserActive(true);
        CarListing updatedListing = carListingRepository.save(listing);
        log.info("Successfully resumed listing ID {} by user {}", listingId, username);
        return carListingMapper.toCarListingResponse(updatedListing);
    }

    @Transactional
    public CarListingResponse markListingAsSold(Long listingId, String username) {
        log.info("User {} attempting to mark listing ID {} as sold", username, listingId);
        CarListing listing = findListingByIdAndAuthorize(listingId, username, "mark as sold");

        if (Boolean.TRUE.equals(listing.getArchived())) {
            log.warn("Attempt to mark archived listing ID {} as sold by user {}", listingId, username);
            throw new IllegalStateException("Cannot mark an archived listing as sold. Please unarchive first.");
        }
        if (Boolean.TRUE.equals(listing.getSold())) {
            log.warn("Listing ID {} is already marked as sold. Throwing exception for user {}.", listingId, username);
            throw new IllegalStateException("Listing with ID " + listingId + " is already marked as sold.");
        }

        listing.setSold(true);
        CarListing updatedListing = carListingRepository.save(listing);

        eventPublisher.publishEvent(new ListingMarkedAsSoldEvent(this, updatedListing, false));
        log.info("Successfully marked listing ID {} as sold by user {}", listingId, username);
        return carListingMapper.toCarListingResponse(updatedListing);
    }

    @Transactional
    public CarListingResponse markListingAsSoldByAdmin(Long listingId) {
        log.info("Admin attempting to mark listing ID {} as sold", listingId);
        CarListing listing = findListingById(listingId);

        if (Boolean.TRUE.equals(listing.getArchived())) {
            log.warn("Admin attempt to mark archived listing ID {} as sold", listingId);
            throw new IllegalStateException("Cannot mark an archived listing as sold. Please unarchive first.");
        }

        if (Boolean.TRUE.equals(listing.getSold())) {
            log.warn("Listing ID {} is already marked as sold. Throwing exception for admin.", listingId);
            throw new IllegalStateException("Listing with ID " + listingId + " is already marked as sold.");
        }
        
        listing.setSold(true);
        CarListing updatedListing = carListingRepository.save(listing);
        log.info("Admin successfully marked listing ID {} as sold", listingId);
        // Publish event with isAdminAction = true
        eventPublisher.publishEvent(new ListingMarkedAsSoldEvent(this, updatedListing, true));
        log.info("Published ListingMarkedAsSoldEvent for listing ID: {} (isAdminAction: true)", updatedListing.getId());
        return carListingMapper.toCarListingResponseForAdmin(updatedListing); // Assuming this method exists
    }

    @Transactional
    public CarListingResponse archiveListing(Long listingId, String username) {
        log.info("User {} attempting to archive listing ID {}", username, listingId);
        CarListing listing = findListingByIdAndAuthorize(listingId, username, "archive");

        if (Boolean.TRUE.equals(listing.getArchived())) {
            log.warn("Listing ID {} is already archived. Throwing exception for user {}.", listingId, username);
            throw new IllegalStateException("Listing with ID " + listingId + " is already archived.");
        }

        listing.setArchived(true);
        CarListing updatedListing = carListingRepository.save(listing);

        eventPublisher.publishEvent(new ListingArchivedEvent(this, updatedListing, false));
        log.info("Published ListingArchivedEvent for listing ID: {} (isAdminAction: false)", updatedListing.getId());
        
        log.info("Successfully archived listing ID {} by user {}", listingId, username);
        return carListingMapper.toCarListingResponse(updatedListing);
    }

    @Transactional
    public CarListingResponse archiveListingByAdmin(Long listingId) {
        log.info("Admin attempting to archive listing ID {}", listingId);
        CarListing listing = findListingById(listingId);

        if (Boolean.TRUE.equals(listing.getArchived())) {
            log.warn("Listing ID {} is already archived. Throwing exception for admin.", listingId);
            throw new IllegalStateException("Listing with ID " + listingId + " is already archived.");
        }

        listing.setArchived(true);
        CarListing updatedListing = carListingRepository.save(listing);
        log.info("Admin successfully archived listing ID {}", listingId);
        // Publish event with isAdminAction = true
        eventPublisher.publishEvent(new ListingArchivedEvent(this, updatedListing, true));
        log.info("Published ListingArchivedEvent for listing ID: {} (isAdminAction: true)", updatedListing.getId());
        return carListingMapper.toCarListingResponse(updatedListing); // Or a specific admin response if available
    }

    @Transactional
    public CarListingResponse unarchiveListing(Long listingId, String username) {
        log.info("User {} attempting to unarchive listing ID {}", username, listingId);
        CarListing listing = findListingByIdAndAuthorize(listingId, username, "unarchive");

        if (!Boolean.TRUE.equals(listing.getArchived())) {
            log.warn("Listing ID {} is not archived. No action taken for unarchive by user {}.", listingId, username);
            throw new IllegalStateException("Listing with ID " + listingId + " is not archived.");
        }

        listing.setArchived(false);
        CarListing updatedListing = carListingRepository.save(listing);
        log.info("Successfully unarchived listing ID {} by user {}", listingId, username);
        // Optionally publish an UnarchivedEvent if one exists
        return carListingMapper.toCarListingResponse(updatedListing);
    }

    @Transactional
    public CarListingResponse unarchiveListingByAdmin(Long listingId) {
        log.info("Admin attempting to unarchive listing ID {}", listingId);
        CarListing listing = findListingById(listingId);

        if (!Boolean.TRUE.equals(listing.getArchived())) {
            log.warn("Listing ID {} is not archived. No action taken for unarchive by admin.", listingId);
            throw new IllegalStateException("Listing with ID " + listingId + " is not archived.");
        }

        listing.setArchived(false);
        CarListing updatedListing = carListingRepository.save(listing);
        log.info("Admin successfully unarchived listing ID {}", listingId);
        // Optionally publish an UnarchivedEvent if one exists
        return carListingMapper.toCarListingResponse(updatedListing); // Or a specific admin response
>>>>>>> a7fbdc3 (Add unit tests for CarListingStatusService methods to ensure proper functionality and error handling)
    }
}
